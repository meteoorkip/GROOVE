package control;

recipe SwitchStmt(node root, node exit, out node entry) {
	// Match only the expression.
	node eroot := rule.SwitchStmt-Init(root);
	// Build the flow for expression.
	entry := Expr(eroot, root);
	try {
		// Switch without statements.
		rule.SwitchStmt-NoStmt(root, exit);
	} else {
		// Switch with statements.
		int stmtMax := rule.SwitchStmt-StmtCount(root);
		int stmtNr :=  rule.help.add(stmtMax, 0);
		node sroot, sentry;
		node sexit := rule.help.assign(exit);
		do {
			sroot := rule.SwitchStmt-WithStmts(root, stmtNr);
			sentry := Stmt(sroot, sexit);
			sexit := rule.help.assign(sentry);
			stmtNr := rule.help.sub(stmtNr, 1);
		} while (rule.help.ge(stmtNr, 0))
	}
}
