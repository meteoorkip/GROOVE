package control;

recipe ConditionalExpr(node root, node exit, out node entry) {
	// Match the condition, true and false components of the expression.
	node croot, troot, froot := rule.ConditionalExpr-Down(root);
	// Build the flow for the condition subexpression.
	entry := Expr(croot, root);
	// Build the flow for the true subexpression.
	node tentry := Expr(troot, exit);
	// Build the flow for the false subexpression.
	node fentry := Expr(froot, exit);
	// Wrap the build as we traverse back in the AST when returning from the recursion.
	rule.ConditionalExpr-Up(root, croot, tentry, fentry);
}
