package control;

recipe AbsMethodDecl(node root, node exit, out node entry) {
	node sroot, sexit, sentry;
	node aroot, aexit, aentry;

	try {
		// Method declaration without statements.
		aexit := rule.AbsMethodDecl-NoStmts(root, exit);
	} else {
		// Method declaration with statements.
		int stmtMax := rule.AbsMethodDecl-StmtCount(root);
		int stmtNr := rule.help.add(stmtMax, 0);
		sexit := rule.help.assign(exit);
		do {
			sroot := rule.AbsMethodDecl-WithStmts(root, stmtNr);
			sentry := Stmt(sroot, sexit);
			sexit := rule.help.assign(sentry);
			stmtNr := rule.help.sub(stmtNr, 1);
		} while (rule.help.ge(stmtNr, 0))
		aexit := rule.help.assign(sentry);
	}

	// Special case: test for a constructor declaration.
	// If the test passes, build the explicit constructor call first.
	try {
		node croot := rule.ConsDecl-ExplicitCall(root);
    	aentry := ExplicitConsCall(croot, aexit);
		aexit := rule.help.assign(aentry);
	}

	try {
		// Method declaration without arguments.
		aentry := rule.AbsMethodDecl-NoArgs(root, aexit);
	} else {
		// Method declaration with arguments.
		int argMax := rule.AbsMethodDecl-ArgCount(root);
		int argNr := rule.help.add(argMax, 0);
		do {
			aroot := rule.AbsMethodDecl-WithArgs(root, argNr);
			aentry := LocalDecl(aroot, aexit);
			aexit := rule.help.assign(aentry);
			argNr := rule.help.sub(argNr, 1);
		} while (rule.help.ge(argNr, 0))
	}
	entry := rule.help.assign(aentry);
	rule.help.createEntry(root, entry);
}
