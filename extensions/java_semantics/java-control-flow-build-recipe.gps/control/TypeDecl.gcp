package control;

recipe TypeDecl(node root, node exit, out node entry) {
	// Build the fields.
	node aroot, aentry, aexit;
	try {
		// Type declaration without fields.
		entry := rule.TypeDecl-NoFields(root, exit);
	} else {
		// Type declaration with fields.
		int fieldMax := rule.TypeDecl-FieldCount(root);
		int fieldNr := rule.help.add(fieldMax, 0);
		aexit := rule.help.assign(exit);
		do {
			aroot := rule.TypeDecl-WithFields(root, fieldNr);
			aentry := FieldDecl(aroot, aexit);
			aexit := rule.help.assign(aentry);
			fieldNr := rule.help.sub(fieldNr, 1);
		} while (rule.help.ge(fieldNr, 0))
		entry := rule.help.assign(aentry);
	}

	// Traverse down on the AST.
	rule.TypeDecl-Down(root);
	// Mark all methods for building.
	alap <
		// Select one method declaration to build next.
		aroot := rule.help.pickAbsMethodDecl();
		// Create an exit node for the method.
		aexit := rule.help.createExit(aroot);
		// Descend into the AST and build everything.
		aentry := AbsMethodDecl(aroot, aexit);
	>
	// Mark all subtypes for building.
	alap <
		// Select one type declaration to build next.
		aroot := rule.help.pickTypeDecl();
		// Create an exit node for the fields.
		aexit := rule.help.createExit(aroot);
		// Descend into the AST and build everything.
		aentry := TypeDecl(aroot, aexit);
	>
}
