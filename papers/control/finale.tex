\section{Conclusions}\label{sec:conclusion}

\subsection{Contributions}
In this paper, we have presented an automaton formalism for controlling rule applications in rule-based systems. We have introduced the notion of failure as the non-applicability of a set of rules in a certain state, and use these failures as an element of control in our automata. The resulting behaviour is defined as the product with a system automaton, an automaton representation of the uncontrolled rule system. The result is a reactive semantics for control expressions. 

%In this paper we have also presented a control language for the specification of control automata. The semantics of this language is described as the control automata that represent programs written in the language.

We have introduced a formalism for guarded control automata and the corresponding product operation, that --- when applied to a deterministic system automaton --- results in a deterministic controlled system automaton. We have proved that the languages of products using a normal and corresponding guarded control automaton coincide.

We have implemented (a superset of) the language presented here in the tool GROOVE \cite{GROOVE}. 

In future work, we like to extend the described control expressions with features such as atomic procedures, transactions and rule parameters.

\subsection{Related Work}

There are two important areas of related work: on the one hand, other
approaches to add control to rule-based systems, and on the other, results from
process algebra.

\paragraph{Other approaches to control.}

Although we have presented this work in the general context of rule-based
systems, as far as we are aware most of the work on explicit control for such
systems has been done for the special case of \emph{graph transformation
systems}; therefore, this is what we will focus on.

First let us remark that in this paper we have concentrated on one particular
method of controlling rule applicability. There are others, such as application
conditions (e.g., \cite{HabelHecTae1996,HabelPen2005}), which have their own
advantages and may very well be used in conjunction with control expressions.

One of the first developments in the direction of using explicit control
expressions for graph transformation was the PROGRES environment; see, e.g.,
\cite{Schurr1990,PROGRES}. The aim here was to obtain a powerful and usable
framework for programmed graph transformation, rather than study the
theoretical properties of such a framework (although a translation into flow
graphs was studied in \cite{ZundorfSch1992}). In the same vein, the control
languages in tools like VIATRA2 \cite{VarroBal2007} and VMTS
\cite{Lengyel+2006} stress power and usability over theoretical properties.
FUJaBA has the appealing graphical \emph{storyboard} language for control
\cite{Fischer+2000}, but here the control is completely integrated with
the rules and does not lend itself at all to an analysis like the one in this
paper.

The theory behind control conditions for rule-based systems has been studied
intensively in the context of \emph{graph transformation units} by Kreowski,
Kuske and others; see, for instance,
\cite{KreowskiKus1996,KreowskiKus1999,Kuske2000}. However, they take a
perspective that is quite different from ours, and indeed represents the
input-output interpretation discussed in Section~\ref{sec:language}, insisting
that ``every description of a binary relation on graphs may be used as a
control condition''.  Also in that interpretation, Schurr \cite{Schurr1997}
contains a systematic discussion of various operators and their meaning, and
Habel and Plump in \cite{HabelPlump01} show the minimality of the control
language consisting only of choice, sequential composition and \alapK. In
\cite{PlumpSteinert04}, a \whileK--\doK{} is added to this language, to
increase usability. We strongly believe that also the \tryK--\elseK{} operator
of this paper is useful in that regard.%  More fundamentally though, we see our
% work as an extension of theirs in the direction of reactive semantics; as we
% have shown in Theorem~\ref{th:io=aut}, their interpretation can be retrieved
% from ours.

Finally, it is worth mentioning that the tools GrEAT \cite{Vizhanyo+2006} and
ATOM${}^3$ \cite{SyrianiVan2007} include
facilities for rule scheduling, but based on \emph{data flow} rather than
control flow.

% %The PROGRES approach \cite{PROGRES}.
% Visual language for controlling graph production systems are used in
% \cite{FUJABA},\cite{AGG} among others. The flow-graph like notation used for
% the specification is equally or more powerful. We believe that a textual
% notation for specifying such graphs or --- as has been described in this work
% --- automata is better comprehensible for programmers.

\paragraph{Failures in process algebra.}

A weak link exists to the concept of failure semantics in process algebra, as
developed in \cite{BrookesHoaRos1984}, leading to the formalism of CSP
\cite{Hoare1985}; and a slightly stronger one to the refusal testing semantics
of \cite{Phillips1986}, where failures can be interspersed with ordinary
actions. The failures in those papers, however, are solely used as
\emph{observations} of the execution capabilities of a process, never to
\emph{control} the process. Thus, despite the superficial similarities, the
models and their purpose are quite different from the research reported in this
paper.

\subsection{Scalability \& Implementation}
An unfortunate consequence of guarded control automata is the fact that there is an exponential blow-up in the possible number of states ($\abs{Q_{\cG}} = 2^{\abs{Q_{\cC}}}$) \emph{and} transitions in applying the $det$ function ($\abs{{\rightarrow}_\cG}$ is in the order of $2^{\abs{{\rightarrow}_\cC}}$) due to the adding of positive and negative guards.

In practice only a small portion of these states will actually be reachable. To deal with this problem, the implementation of this work in \cite{GROOVE} uses a lazy construction of $\cG$ states during generation of the guarded system automaton. In this way, only those states are created that are (obviously) possible, but - more important - are in fact \emph{used}. In a small test case that we have performed using a control program and a corresponding control automaton with 19 states and 9 failure transitions, only 17 distinct guarded control states were used during generation of the guarded system automaton (of a maximum possible count of 524288). In our experience, a single \Lrule{Rule} is rarely used twice in a control program, limiting the number of guarded control states and the number of transitions.

\iffull
\section{Future Work}\label{sec:futurework}
By allowing named procedures in our control language, it is possible to simplify the product automaton to abstract from the details of such procedures, by replacing the application of the procedure with a single transition. Intuitively, control can be used to simplify rules that model complex processes, i.e. processes that can not be expressed by a single rule. By allowing this atomicity, we can visualise the process as a single action.

These same procedures can be used for specifying transactions. When a procedure can not be exited successfully, one could require to roll back the preceding rule application. Intuitively: the process spread over a group of rules, could not be finished completely. Would one consider the process being a single rule, it would not have been applied at all.

While we solved the problem of controlling the order of rules, we could extend this work with parameterized rule applications. A rule application would bind certain nodes to variables, where these bound variables can be used in the application other rules. This allows control of \emph{where} the rule is applied (in case of more then one option).
For example, one might like to do an operation on all elements of a linked list. Assuming the operation on a single element can be specified with a single rewrite rule, one could require the operation to be finished before applying any other rules by using the {\tt alap} keyword. The structure of the linked list however, calls for coding the next element of the list to do the operation on; this avoids the complex task of finding the first element the operation has not yet been applied on (which might not even be possible). With parameters, the next element can be matched and bound to a variable, to be used as the current element in the next rule application. This avoid the use of control information in the states (and rules) even more. 

\fi
