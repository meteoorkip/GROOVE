\section{Control Language}\label{sec:language}

% In this section we introduce a language \Lang{} for the specification of
% control programs. The purpose of this language is to provide a convenient
% syntax for control automata. \Lang{} is defined by the following grammar:

For the convenient specification of control automata, we propose to use a
control language along the lines of what has previously been proposed in, e.g.,
\cite{HabelPlump01}. We will use the following grammar:
%
\[ P := \Lrule{rule} \mmid \Ltrue \mmid \Lor{P_1}{P_2} \mmid \Lseq{P_1}{P_2} \mmid
\Lstar{P} \mmid \Lalap{P} \mmid \Ltryelse{P_1}{P_2} 
\]
%
% \begin{lstlisting}[language=Control,caption=The grammar of the control language,label=lst:grammar]
% P := RuleId
%    | TRUE
%    | P "|" P
%    | P ";" P
%    | P "*"
%    | alap P
%    | try P [ else P ]
% \end{lstlisting}
These constructs have the following intuitive meaning:
% An \emph{elementary} program consists of a $\Lrule{rule}$, which means that
% this rule is scheduled. From elementary programs, more complex control programs
% can be built, namely:
% %
\begin{itemize}
\item \Lrule{rule} schedules the execution of a single rule (named
  \Lrule{rule});
\item \Ltrue{} behaves like a rule that is always successful
  and does not change the underlying structure;
\item \Lor{P_1}{P_2} is the \emph{non-deterministic choice} of $P_1$ and $P_2$;
\item \Lseq{P_1}{P_2} is the \emph{sequential composition} of $P_1$ and $P_2$;
\item \Lstar{P} (the \emph{Kleene closure}) schedules $P$ an arbitrary number
  of times;
\item \Lalap{P} (\emph{as long as possible}) schedules $P$ until it fails;
\item \Ltryelse{P_1}{P_2} schedules $P_1$ first, and schedules $P_2$ in case
  $P_1$ fails.
\end{itemize}
%
Traditionally (e.g., in \cite{HabelPlump01}), the effect of such control
programs is defined in terms of the resulting input-output behaviour for
the rule system at hand. Formally, this is captured by a function
$\semio-:\Lang\rightarrow \Data\times \Data$. For instance, for some of the
operators the defining clauses are as follows, where $r$ is a rule and $i$ is a application identifier:
%
\begin{eqnarray*}
\semio{\Lrule{rule}}
   & = & \setof{(d,d')\mid \exists r,i: d\trans{r,i} d'} \\
\semio{\Lseq{P_1}{P_2}}
   & = & \setof{(d,d')\mid
                (d,d'')\in \semio{P_1}, (d'',d')\in \semio{P_2}} \\
\semio{\Lstar{P}}
   & = & \setof{(d,d) \mid d\in \Data} \cup
         \setof{(d_0,d_n)\mid (d_0,d_1),\ldots,(d_{n-1},d_n)\in \semio P} \\
\semio{\Lalap{P}}
   & = & \setof{(d,d')\in \semio{\Lstar{P}} \mid
                          \nexists d'': (d',d'')\in \semio P} 
\end{eqnarray*}
%
Using control automata, we express the reactive rather than the input-output
behaviour of $\Lang$; or in other words, it is a small-step semantics rather
than a big-step semantics. An advantage, furthermore, is that we capture the
meaning of control expressions without reference to any particular rule system.
However, our approach inevitably implies that the meaning of, for instance,
\alapK{} changes with respect to the above definition: rather than considering
a sub-expression ``possible'' if it can run to a successful completion, we
consider it ``possible'' if it can do a \emph{single} step. For example, in $alap\{a;b;\}$, the \Lalap~repeats its body while the first rule is possible --- in this case when $a$ is possible.

