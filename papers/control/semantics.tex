The semantics of \Lang{} is defined through a set of operators over \CAut{}
corresponding to the constructs of the language. For this purpose, we first
need to define what it means for an automaton to \emph{fail}; this is an
important concept in the definition of \alapK{} and \tryK-\elseK. The failure
of an automaton is based on the non-applicability of its initial actions, being
those rules that are scheduled as a first action.  This set of initial actions
is defined as follows:

\begin{definition}[initial control actions]
The initial actions of a given control automaton $\cC$ are defined by
\begin{align*}
\Init(\cC) &= \setof{ n \mid q_0 \arrow{F_i \dotsc F_n}\arrow{n} } \cup
              \setof{ \delta \mid \exists q':q_0 \arrow{F_0 \dotsc F_n} q' \in S }
\end{align*}
\end{definition}
%
Here $n$ represent a rule. The result is a set of rules that can be performed first.
A $\delta$ in the result indicates that in the given automaton there is
a path from the start state to a success state consisting of only failure
transitions. The automaton is considered to be always successful. We will see
that a failure transition for $\cC$ is typically only created when
$\delta\notin \Init(\cC)$.

In the definitions below, we use control automata $\cC_i = (Q_i, \Sigma,
\rightarrow_i, q_{0_i}, S_i)$ for $i=1,2$, and we use distinct fresh states
$q_N,q_M\notin Q_1$.  Due to the lack of space in this paper, we restrict
ourselves to the most interesting language constructs: single rules, sequential
composition, \alapK{} and \tryK--\elseK.
%
\begin{eqnarray*}
\cC_{\Lrule{rule}} & =
   & ( \setof{q_M,q_N}, \Sigma, \setof{(q_N,\Lrule{rule},q_M)}, q_M, \setof{q_N}) \\
\cC_1;\cC_2 & =
   & (Q_{1} \setminus S_1 \cup Q_{2}, \Sigma, \rightarrow, q_{0,1}, S_2), \text{where} \\
  && {\rightarrow} =
         \begin{array}[t]{@{}l}
             {\rightarrow_{1}} \setminus \setof{(q,x,q') \mid q \arrow{x}_1 q' \in S_1}
               \cup \setof{ (q,x,q_{0,2}) \mid q \arrow{x}_1 q' \in S_1 } \\
             {} \cup {\rightarrow_{2}}
         \end{array} \\
\cC_1 \alap & =
   & (Q_1 \setminus S_1 \cup \setof{q_N}, \Sigma, \rightarrow, q_{0,1}, \setof{q_N}),
      \text{where} \\
  && {\rightarrow} =
         \begin{array}[t]{@{}l}
             \rightarrow_1 \setminus \setof{ (q,x,q') \mid q \arrow{x}_1 q' \in S_1}
	        \cup \setof{ (q,x,q_{0,1}) \mid q \arrow{x}_1 q' \in S_1 } \\
             {} \cup \setof{(q_{0,1},\Init(C_1),q_N) \mid \delta \not\in \Init(C_1)}
         \end{array} \\
\cC_1 \tryelse \cC_2 & =
   & (Q_1 \cup Q_2, \Sigma, \rightarrow, q_{0,1}, S_1 \cup S_2), \text{where} \\
  && {\rightarrow} = {\rightarrow_{1}} \cup {\rightarrow_{2}}
          \cup \setof{(q_{0,1},\Init(C_1),q_{0,2}) \mid \delta \not\in \Init(C_1) }
\end{eqnarray*}
%
The following points are noteworthy:
\begin{itemize}
\item In the sequential composition $\cC_1;\cC_2$, every transition in $\cC_1$
  to a success state is redirected to the start state of $\cC_2$.
\item In the ``alap closure'' $\cC_1\alap$, transitions to success states are
  redirected to the start state. Optionally, a failure transition of the \emph{init} of the automaton is created to a fresh state $q_N$.
\item In the ``try-else'' operation $\cC_1\tryelse \cC_2$, the start state of
  $\cC_1$ is optionally connected to the start state of $\cC_2$ by a failure
  transition.
\end{itemize}
%
Without proof, we state the following property:
%
\begin{proposition}
$\CAut$ is closed under the constructions defined above.
\end{proposition}
%
This gives rise to the following semantics function $\semaut-: \Lang
\rightarrow \CAut$:
%
\begin{align*}
\semaut{\Lrule{rule}} &= \cC_{\Lrule{rule}} \\
\semaut{\Lseq{P_1}{P_2}} &= \semaut{P_1};\semaut{P_2}\\
\semaut{\Lalap{P_1}} &= \semaut{P_1}\alap\\
\semaut{\Ltryelse{P_1}{P_2}} &= \semaut{P_1} \tryelse \semaut{P_2}
\end{align*}
%
As we have pointed out above, this differs from the semantics studied in
\cite{HabelPlump01} (and elsewhere) in the treatment of failure, which for us
is the failure of a small step but for them the failure of a big step. For
instance, the control program $P=\Lseq{\Lalap{(\Lseq{\Lrule a}{\Lrule
b})}}{\Lrule{c}}$ imposed on a rule system where $d\trans{\Lrule
a,i}d'\trans{\Lrule{c},j}d''$ but $\nexists k:d'\trans{\Lrule{b},k}$ gives rise
to $(d,d'')\in \semio{P}$, whereas $\semaut{P}\times \cA_d$ only contains the
transition $(d,q_0)\trans{\Lrule a,i} (d',q_1)\notin S$, without further
outgoing transitions.


% Of course, it is important that the new semantics is consistent with the
% existing one. For the purpose of comparison, let $\cA_d$ be the pure system
% automaton with initial state $d$, constructed by freely exploring all
% applicable rules as suggested in Section~\ref{sec:aut}, and for all $P\in
% \Lang$ let $\cA_{P,d}=\cA_d\times \semaut P$; i.e., this is the pure automaton
% controlled by the program. We then have the following result:
% %
% \begin{theorem}\label{th:io=aut}
% For all $P\in \Lang$, $\semio P = \setof{(d,d') \mid q_{0,P,d}
%   \trans{\ell_1\cdots \ell_n}_{P,d} (d',c) \in S_{P,d}}$.
% \end{theorem}
% %
% In words, the input-output behaviour can be retrieved by using the input data
% as start state, and interpreting the data part of the reachable success states
% as output.
