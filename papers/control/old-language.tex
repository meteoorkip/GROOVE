\section{Control Language}\label{sec:language}

% In this section we introduce a language \Lang{} for the specification of
% control programs. The purpose of this language is to provide a convenient
% syntax for control automata. \Lang{} is defined by the following grammar:

For the convenient specification of control automata, we propose to use a
control language along the lines of what has previously been proposed in, e.g.,
\cite{HabelPlump01}. We will use the following grammar:
%
\[ P := \Lrule{rule} \mmid \Ltrue \mmid \Lor{P_1}{P_2} \mmid \Lseq{P_1}{P_2} \mmid
\Lstar{P} \mmid \Lalap{P} \mmid \Ltryelse{P_1}{P_2} 
\]
%
% \begin{lstlisting}[language=Control,caption=The grammar of the control language,label=lst:grammar]
% P := RuleId
%    | TRUE
%    | P "|" P
%    | P ";" P
%    | P "*"
%    | alap P
%    | try P [ else P ]
% \end{lstlisting}
These constructs have the following intuitive meaning:
% An \emph{elementary} program consists of a $\Lrule{rule}$, which means that
% this rule is scheduled. From elementary programs, more complex control programs
% can be built, namely:
% %
\begin{itemize}
\item \Lrule{rule} schedules the execution of a single rule (named
  \Lrule{rule});
\item \Ltrue{} behaves like a rule that is always successful
  and does not change the underlying structure;
\item \Lor{P_1}{P_2} is the \emph{non-deterministic choice} of $P_1$ and $P_2$;
\item \Lseq{P_1}{P_2} is the \emph{sequential composition} of $P_1$ and $P_2$;
\item \Lstar{P} (the \emph{Kleene closure}) schedules $P$ an arbitrary number
  of times;
\item \Lalap{P} (\emph{as long as possible}) schedules $P$ until it fails;
\item \Ltryelse{P_1}{P_2} schedules $P_1$ first, and schedules $P_2$ in case
  $P_1$ fails.
\end{itemize}
%
Traditionally (e.g., in \cite{HabelPlump01}), the effect of such control
programs is defined in terms of the resulting input-output behaviour for
arbitrary rule systems. Formally, this can be captured by a function
$\semio-:\Lang\rightarrow \Data\times \Data$. For instance, for some of the
operators the defining clauses are as follows:
%
\begin{eqnarray*}
\semio{\Lrule{rule}}
   & = & \setof{(d,d')\mid \exists r,i: d\trans{r,i} d'} \\
\semio{\Lseq{P_1}{P_2}}
   & = & \setof{(d,d')\mid
                (d,d'')\in \semio{P_1}, (d'',d')\in \semio{P_2}} \\
\semio{\Lstar{P}}
   & = & \setof{(d,d) \mid d\in \Data} \cup
         \setof{(d_0,d_n)\mid (d_0,d_1),\ldots,(d_{n-1},d_n)\in \semio P} \\
\semio{\Lalap{P}}
   & = & \setof{(d,d')\in \semio{\Lstar{P_1}} \mid
                          \nexists d'': (d',d'')\in \semio P} 
\end{eqnarray*}
%
Using control automata, we can express the reactive rather than the
input-output behaviour of rule systems. This has the additional advantage that
the semantics of is captured without reference to any particular rule system.

\iffull

\subsection{Language Semantics}
In this subsection we express the semantics of the language elements by expressing the allowed \emph{traces} for the terms. To define the trace semantics of conditional statements, we require a notion of failure of a statement. Given a certain state $S$ and statement $P$, $P$ fails iff all first reachable {\tt RuleId} elements $P$ are disabled in $S$. Failure is undefined for those terms that can terminate without any {\tt RuleId}. We introduce the bar notation for sets of {\tt RuleId}s to define a failure-set: those {\tt RuleId}s required to be disabled for the statement to fail.\\
\\
The \emph{Init} function defines the first reachable $RuleId$ elements of a program.
We define a function $Init: \text{\tt Lang} \rightarrow \{ RuleId \} \cup \{ \delta \}$ that returns the initial {\tt RuleId} for a program specified in {\tt Lang}. A $\delta$ in the result expresses empty --- or rather immediate --- termination.

\begin{definition}[Init Function]
function Init $P$ $\rightarrow$ $\{ Name \}$ is defined as:\\
\begin{align*}
Init(\Ltrue) &= \{ \delta \}\\
Init(\Lrule{RuleId}) &= \{RuleId\}\\
Init(\Lor{P_1}{P_2}) &= Init(P_1) \cup Init(P_2)\\
Init(\Lseq{P_1}{P_2}) &= \begin{cases}
	Init(P_1)& \text{if $\delta \not\in Init(P_1)$,}\\
	Init(P_1) \setminus \{ \delta \} \cup Init(P_2) & \text{if $\delta \in Init(P_1)$.}\\
\end{cases}\\
Init(P*) &= \{ \delta \}\\
Init(alap \msp P) &= Init(P) \cup \{ \delta \}\\
Init(\Lifskip{P_1}{P_2}) &= Init(P_1;P_{2}) \cup \{\delta\}\\
Init(\Lifelse{P_1}{P_2}{P_3}) &= Init(P_1;P_{2}) \cup Init(P_{3})\\
Init(\Ltryskip{P}) &= Init(P) \cup \{ \delta \}\\
Init(\Ltryelse{P_{1}}{P_{2}}) &= Init(P_{1}) \cup Init(P_{2})\\
Init(\Lwhiledo{P_1}{P_2}) &= Init(P_1;P_2) \cup \{ \delta \}\\
Init(\Ldowhile{P_1}{P_2}) &= \begin{cases}
	Init(P_1) & \text{if $\delta \not\in Init(P_1)$,}\\
	Init(P_1) \cup Init(P_2) & \text{if $\delta \in Init(P_1)$.}\\
\end{cases}\\
Init(\Lchoice{P_1}{P_2}{P_n}) &= Init(P_1) \cup Init(\Lorr{P_2}{P_n})\\
\end{align*}
\end{definition}

For example, the init of {\tt alap a}  is $\{ {\tt a}, \delta \}$. The $\delta$ indicates that the program at hand can succesfully terminate without consuming any symbols. For the given example, this is true in case rule {\tt a} is not applicable from the start.

For expressing the trace semantics of the language, we require a function $Fail: {\tt Lang} \rightarrow \text{\tt Name} \cup \text{\tt Fail}$, that returns  
the $Init$ of a given program written in $L$ as a failure-set.

\begin{math}
Fail(P) = \begin{cases}
Init(P)& \text{if $\delta \not\in Init(P)$,}\\
\emptyset& \text{if $\delta \in Init(P)$.}
\end{cases}
\end{math}

The failure \emph{Fail} of a (sub-)program $P$ is defined as the failure of $Init(P)$. However, when the \emph{Init} is not defined, i.e. it contains a $\delta$, then the failure is not defined either. We use the set notation for the failure of a set of names. E.g. $[a,b]$ expresses the failure-set of rule names $a$ and $b$.

Given these definitions, we can express the semantics of the program elements as the traces that are accepted by those elements. We distinguish between \emph{all} traces and \emph{successful} traces. A successful trace is a sequence of {\tt RuleId}s and Failure-sets ${(Name \cup Fail)*}$ (here, $*$ is the \emph{Kleene star}, giving all possible words written in the alphabet $Name \cup Fail$), that, when completely consumed by a program, has reached the end of the program. These traces are defined for the terms of the language as follows:
%
\begin{align*}
\trace{\Lrule{RuleId}}_{s} &= \{ RuleId \}\\
\trace{\Ltrue}_{s} &= \{ \epsilon \}\\
\trace{\Lor{P_{1}}{P_{2}}}_{s} &= \trace{P_{1}}_{s} \cup \trace{P_2}_{s}\\
\trace{\Lseq{P_{1}}{P_{2}}}_{s} &= \trace{P_{1}}_{s} . \trace{P_2}_{s}\\
\trace{\Lstar{P}}_{s} &= \{\epsilon\} . \trace{P}_{s}*\\
\trace{\Lalap{P}}_{s} &= \trace{P}_{s}* . Fail(P)\\
\trace{\Lifskip{P_1}{P_{2}}}_{s} &= \trace{P_1;P_2}_{s} \cup Fail(P_1)\\
\trace{\Lifelse{P_1}{P_{2}}{P_{3}}}_{s} &=
				\trace{P_1;P_{2}}_{s} \cup Fail(P_1).\trace{P_3}_{s}\\
\trace{\Ltryskip{P_1}}_{s} &= \trace{P_{1}}_{s} \cup Fail(P_1)\\
\trace{\Ltryelse{P_1}{P_2}}_{s} &=
				\trace{P_{1}}_{s} \cup Fail(P_1) . \trace{P_2}_{s}\\
\trace{\Lwhiledo{P_1}{P_2}}_{s} &= \trace{P_1;P_2}_{s}* . Fail(P_1)\\
\trace{\Ldowhile{P_1}{P_2}}_s &= \trace{P_1}_s . \trace{P_2;P_1}_s* . Fail(P_2)\\
\trace{\Lchoice{P_{1}}{P_2}{P_n}}_{s} &= \trace{P_{1}}_{s} \cup \trace{\Lorr{P_2}{P_n}}_{s}\\
\end{align*}
%
The \emph{all traces} function gives those traces that can succesfully be consumed by the program, do not require the program to be terminated afterwards. These traces are defined for the terms of the language as follows:
%
\begin{align*}
\trace{\Lrule{RuleId}}_{a} &= \{Rule,\epsilon\}\\
\trace{\Ltrue}_{a} &= \{ \epsilon \}\\
\trace{\Lor{P_1}{P_2}}_{a} &= \trace{P_{1}}_{a} \cup \trace{P_{2}}_{a}\\
\trace{\Lseq{P_1}{P_2}}_{a} &= \trace{P_{1}}_{a} \cup \trace{P_{1}}_{s} . \trace{P_{2}}_{a}\\
\trace{\Lrule{P*}}_{s} &= \{\epsilon\} . \trace{P}_{s}* . \trace{P}_{a}\\
\trace{\Lalap{P}}_{a} &= \trace{P}_{s}* . (\trace{P}_{a} \cup Fail(P))\\
\trace{\Lifskip{P_1}{P_2}}_{a} &= \trace{P_1;P_{2}}_{a} \cup Fail(P_1)\\
\trace{\Lifelse{P_1}{P_2}{P_3}}_{a} &= \trace{P_1;P_{2}}_{a} \cup Fail(P_1).\trace{P_{3}\rtrace}_{a}\\
\trace{\Ltryskip{P_1}}_{a} &= \trace{P_{1}}_{a} \cup Fail(P_{1})\\
\trace{\Ltryelse{P_1}{P_2}}_{a} &= \trace{P_{1}}_{a} \cup Fail(P_{1}).\trace{P_{2}}_{a}\\
\trace{\Lwhiledo{P_1}{P_2}}_{a} &= \trace{P_1;P_2}_{s}* . (\trace{P_1;P_2}_{a} \cup Fail(P_1))\\
\trace{\Ldowhile{P_1}{P_2}}_a &= \trace{P_1}_a \cup \trace{P_1}_s . \trace{\Lseq{P_2}{P_1}}_s* . ( \trace{\Lseq{P_2}{P_1}}_a \cup Fail(P_2)\\
\trace{\Lchoice{P_1}{P_2}{P_n}}_{a} &= \trace{P_1}_{a} \cup \trace{\Lorr{P_2}{P_n}}_{a}\\
\end{align*}

The \emph{Kleer star} notation for a set of traces means that an elements of a this set can be concatenated with any elements of that set any number of times.

An example reduction of the success traces of the program \Lseq{\Lalap{a}}{b} is:
\begin{math}
\trace{\Lseq{\Lalap{a}}{d}}_{s} = 
\trace{\Lalap{a}}_{s} . \trace{b}_{s} =
\trace{a}_{s}* . Fail(a) . \trace{b}_{s} =
a*.[a].b\\
\end{math}

The set $[a]$ corresponds to the failure-set consisting of the $a$ rule. Thus, $a$ can be applied any number of times, but must not be applicable anymore before $b$ is applied.

The concatenation of a set of trace with the $\emptyset$ is given by the direct (cartesian) product with $\emptyset$. If we want to compute the successful traces of 

\iffull

\begin{definition}[Semantically Equivalence of Traces]

Semantic equavalence relationship $SE$ is defined over $Name \cup {\{ 2^Name \}}^*$, $A \cup Fail_A$ as\\
\begin{math}
\\
\overline{\{a,b\}}.\overline{\{b\}} SE \overline{\{a,b\}}\\
\overline{\{a\}}.\overline{\{a\}} SE \overline{\{a\}}\\
\overline{\{a\}}.\overline{\{b\}} SE \overline{\{a,b\}}\\
\overline{\{a\}}.a SE \overline{\{a\}}\\
\end{math}
\end{definition}

the following elements, which can be expressed in terms of one ore more other language features and so can be regarded as syntactic sugar:

\begin{itemize}
\item \Lifskip{S_1}{S_2} can be represented by \Lifelse{S_1}{S_2}{\{TRUE\}}.
\item \Ltryskip{S} can be represented by \Ltryelse{S}{\{TRUE\}}.
%\item $\#S$ can be represented by \Lalap{\{S;\}}.
%\item $S+$ can be represented by $S;S*$.
\end{itemize}

Also, some of the statements can occur in semantic equivalence \todo{How is this different from the sugar?}.

\begin{itemize}
\item \Lwhiledo{S_1}{S_2} $\Leftrightarrow$ \Lalap{S_1;S_2}
\item \Ldowhile{S_1}{S_2} $\Leftrightarrow$ $S_1;$\Lalap{S_2;S_1}
\item \Lifelse{S_1}{S_2}{S_3} $\Leftrightarrow$ \Ltryelse{S_1;S_2}{S_3}.
\end{itemize}

In fact, only sequential composition, \alap{}, \tryelse{}{}{}, sequential composition and the \emph{Kleene star} are required to reach the expression strength of the language.

\fi
\fi
