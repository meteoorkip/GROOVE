\section{Rule Systems and Automata}\label{sec:automata}

Since this paper is placed in the general context of rule systems, we first
define our conception of such systems.

\begin{definition}[rule system]\label{def:rule}
  A rule system is a set of rules, $\Rule$, which act on a universe of data
  structures, $\Data$, in a manner captured by a partial \emph{derivation}
  function $\delta: \Data\times \Rule\times \Id\rightharpoonup \Data$, where
  $\Id$ is a set of \emph{application identifiers}.
\end{definition}
%
The fact that $\delta(d,n,i)=d'$, which we will henceforth denote
$d\arrow{n,i}d'$, expresses that rule $n$ can be applied to structure $d$,
resulting in a new structure $d'$. The identifier $i$ provides information on
how $n$ was applied precisely and therefore has the role of a match;
this has the effect of making the result $d'$ unambiguous.

Without going into details, we note that this definition encompasses a wide
spectrum of systems, including Turing machines, Petri nets, and various kinds
of rewrite systems.

The meaning of a rule-based system is usually taken to be the \emph{normal
forms} reachable from a given input structure $d$; that is, those structures
$d'\in \Data$ such that there exists a chain of derivations $d \trans{r_1,i_1}
\trans{r_2,i_2} \cdots \trans{r_n,i_n} d'$ and there are no further derivations
possible from $d'$. In other words, one is interested in the
\emph{transformational} or \emph{input-output} behaviour of the rule system. In
this paper, on the other hand, we consider the \emph{temporal} or
\emph{reactive} behaviour of rule systems, which can only be captured by taking
intermediate steps into account. To formalise the reactive behaviour, we use
\emph{automata}.  For the sake of simplicity, in this paper we identify rules
with their names; hence, we will use rules as (part of) transition labels.
Throughout the paper, we will use \Rule{} to stand for the rule system under
consideration, with associated sets $\Data$ of data structures and $\Id$ of
application identifiers.

\subsection{Automata}
\label{sec:aut}

We distinguish system automata and control automata, with the same structure. System automata represent the behaviour of a system, whereas control automata specify the controlling behaviour that can be added to a system.
% In this section we present the formal definition of control automata. The
% meaning of such an automaton is expressed as its product with a so-called
% system automaton, which represents the uncontrolled behaviour of a rule system.
%
% First, we give a general definition of automaton, which we specialise for
% system automata and control automata.
%
\begin{definition}[automaton]\label{def:aut}
An automaton $\cA$ is a tuple $(Q, \Sigma, \rightarrow, q_0, S)$ where
\begin{itemize}
\item $Q$ is a finite set of states;
\item $\Sigma$ is a finite alphabet, which may or may not include the special
  symbol $\lambda$;
\item ${\rightarrow} \subseteq Q \times \Sigma \times Q$ is a set of
  transitions;
\item $q_0 \in Q$ is the start state;
\item $S \subseteq Q$ is a set of success states.
\end{itemize}
$A$ is called \emph{deterministic} if for all $q\in Q$ and $\ell\in \Sigma$, $q
\trans{\ell} q_1$ and $q \trans{\ell} q_2$ implies $q_1 = q_2$ and $\ell \neq \lambda$.
\end{definition}
%
Intuitively, a success state is a state in which it is correct to halt
execution. The special symbol $\lambda$ stands for an \emph{invisible} step. We
use the following notations:
%
\begin{eqnarray*}
q \trans{\ell_1\cdots \ell_n} q'
  & \enspace:\Leftrightarrow\enspace
  & q \arrow{\ell_1} \cdots \arrow{\ell_n} q' \\
q \Arrow\epsilon q'
  & \enspace:\Leftrightarrow\enspace
  & \exists n: q \arrow{\lambda^n} q' \\
q \Arrow{a_1\cdots a_n} q'
  & \enspace:\Leftrightarrow\enspace
  & q \Arrow\epsilon \arrow{a_1} \cdots \Arrow\epsilon \arrow{a_n} q' \enspace.
\end{eqnarray*}
%
Moreover, we use $q\arrow a{}$ to denote $\exists q':q\arrow a q'$, etc.
Finally, we define the \emph{language} of an automaton as the set of all
traces $\Tr(\cA)$, with a distinguished subset of \emph{successful} traces $\STr(\cA)$; i.e., for all
$\cA\in \Aut$:
%
\[%\begin{array}{l}
   \cL(\cA) = (\Tr(\cA),\STr(\cA)), \enspace\text{where}\enspace
   \begin{array}{l@{{\;}}l}
   \Tr(\cA)
       & = \setof{w \in (\Sigma\setminus\lambda)^* \mid q_0\Trans{w}{}} \\
   \STr(\cA)
       & = \setof{w \in (\Sigma\setminus\lambda)^* \mid q_0\Trans{w }\Arrow{\epsilon} q'\in S} \\
   \end{array}
%\end{array}
\]
%
It follows from standard theory that every language (to be precise, every pair
$(\Tr,\STr)$ with $\Tr\subseteq(\Sigma\setminus\lambda)^*$ non-empty and
prefix-closed and $\STr \subseteq \Tr$) is uniquely (up to isomorphism)
represented by a deterministic automaton.

\paragraph{System Automata.}

A system automaton is essentially a state-transition system describing the
step-by-step derivations of a rule system.

\begin{definition}[system automaton]
  A \emph{system automaton} is an automaton with $\Sigma = (\Rule \times
  \Id) \cup \{ \lambda \}$, such that every $q\in Q$ has an associated data
  structure $d_q\in \Data$, satisfying the following consistency properties:
\begin{eqnarray*}
q \arrow\lambda q'
  & \enspace:\Leftrightarrow\enspace
  & d_q=d_{q'} \\
q \arrow{r,i} q'
  & \enspace:\Leftrightarrow\enspace
  & d_q \arrow{r,i} d_{q'} \enspace.
\end{eqnarray*}
For arbitrary $d\in \Data$, the \emph{free automaton} $\cA_d$ is a system
automaton with data structures as states and derivations as transitions, which
is the smallest such that $q_0=d$, and for all $d'\in Q$ and
$\delta(d',n,i)=d''$, $d''\in Q$ and $d'\trans{n,i} d''$.
\end{definition}
%
The set of system automata is denoted $\SAut$. The $(r,i)$-labelled transitions
are essentially rule applications, whereas in a $\lambda$-transition no data
transformation occurs. Given that states are data structures combined with some
extra information, a $\lambda$-transition represents an (undefined) change in
this extra information. The free automaton is the result of uncontrolled rule
application at every state.
%
\begin{figure}[tb]
\centering
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,auto,semithick,>=stealth',initial text=]
\tikzstyle{every state}=[shape=circle,draw]
\node[state,initial,accepting] (s0)                     {$s_0$};
\node[state,accepting]         (s1) [right of=s0]       {$s_1$};
\node[state,accepting]         (s2) [right of=s1]       {$s_2$};
\node[state,accepting]         (s3) [below right of=s0] {$s_3$};
\node[state,accepting]         (s4) [below right of=s1] {$s_4$};
\node[state,accepting]         (s5) [below right of=s2] {$s_5$};
%\node[state,accepting](s2) [below right of=s0] {$s_2$};
%\node[shape=circle](s4) [right of=s2]{};
\path[->]
(s0) edge node        {$\scriptstyle\propagate,0$} (s1)
     edge node [swap] {$\scriptstyle\dispatch,2$}  (s3)
(s1) edge node        {$\scriptstyle\propagate,1$} (s2)
     edge node [swap] {$\scriptstyle\dispatch,2$}  (s4)
(s2) edge node [swap] {$\scriptstyle\dispatch,2$}  (s5);
\end{tikzpicture}
\caption{Example System Automaton}
\label{fig:sa_example}
\end{figure}

\begin{example}\label{ex:sa}
Figure \ref{fig:sa_example} shows a system automaton based on two rules:
\begin{itemize}
\item[\propagate]: This rule represents a passenger \emph{entering} a train.
\item[\dispatch]: This rule represents the \emph{closing} of the train door.
\end{itemize}
%
This simple process is shown for a start state where two passengers want to
enter the train. The \propagate-rule can be applied twice. The door can be
closed once, regardless of the passengers being inside or outside the train.
All states are successful in the free automaton.
\end{example}

\paragraph{Determinism.}

We follow standard automata theory in equating all automata with their sets of
traces; or in other words, every automaton is considered to be essentially the
same as its determinisation (according to the standard powerset construction).
For system automata, this is justified because their labels are enriched so
that they do not only contain rule names but also application identifiers.
Only the rule names are typically observable; for instance, verification
methods such as model checking only take note of the rule name part of the
labels.

If we would project all $\Rule\times\Id$-labels of a system automaton onto
their first components, the resulting automaton would in general be
non-deterministic; but this type of non-determinism can \emph{not} be resolved
without changing the meaning of the automaton. This implies that this
projection is not well-defined modulo trace equivalence of the automata.
%
\begin{figure}
\[\begin{tabular}{c@{{\qquad}}c@{{\qquad}}c}
\begin{tikzpicture}[shorten >=1pt,node distance=1.5cm,auto,
    bend angle=45,semithick,>=stealth',initial text=,baseline=(q0.north)]
\tikzstyle{every state}=[shape=circle,draw,minimum size=5mm]
\node[state,initial] (q0) {};
\node[state] (q1) [below left of=q0] {};
\node[state,accepting] (q2) [below of=q1] {};
\node[state] (q3) [below right of=q0] {};
\node[state,accepting] (q4) [below of=q3] {};
\path[->] (q0) edge node[swap] {$\scriptstyle a,0$} (q1)
               edge node {$\scriptstyle a,1$} (q3)
          (q1) edge node {$\scriptstyle b,2$} (q2)
          (q3) edge node {$\scriptstyle c,3$} (q4);
\end{tikzpicture} &
\begin{tikzpicture}[shorten >=1pt,node distance=1.5cm,auto,
    bend angle=45,semithick,>=stealth',initial text=,baseline=(q0.north)]
\tikzstyle{every state}=[shape=circle,draw,minimum size=5mm]
\node[state,initial] (q0) {};
\node[state] (q1) [below left of=q0] {};
\node[state,accepting] (q2) [below of=q1] {};
\node[state] (q3) [below right of=q0] {};
\node[state,accepting] (q4) [below of=q3] {};
\path[->] (q0) edge node[swap] {$\scriptstyle a,0$} (q1)
               edge node {$\scriptstyle a,0$} (q3)
          (q1) edge node {$\scriptstyle b,2$} (q2)
          (q3) edge node {$\scriptstyle c,3$} (q4);
\end{tikzpicture} &
\begin{tikzpicture}[shorten >=1pt,node distance=1.5cm,auto,
    bend angle=45,semithick,>=stealth',initial text=,baseline=(q0.north)]
\tikzstyle{every state}=[shape=circle,draw,minimum size=5mm]
\node[state,initial] (q0) {};
\node[state] (q1) [below of=q0] {};
\node[state,accepting] (q2) [below left of=q1] {};
\node[state,accepting] (q3) [below right of=q1] {};
\path[->] (q0) edge node {$\scriptstyle a,0$} (q1)
          (q1) edge node[swap] {$\scriptstyle b,2$} (q2)
               edge node {$\scriptstyle c,3$} (q3);
\end{tikzpicture}
\\
$(a)$ & $(b)$ & $(c)$
\end{tabular}\]\vspace*{-4mm}
\caption{Different types of non-determinism}
\label{fig:det}
\end{figure}%
%
For instance, in Fig.~\ref{fig:det}, automata $(b)$ and $(c)$ are language
equivalent, whereas $(a)$ is different; however, after projection onto the rule
names, $(a)$ and $(b)$ appear essentially the same (viz., isomorphic) whereas $(c)$ appears to be different.

To avoid this type of confusion, we prefer to work only with deterministic
system automata.  Obviously, this can be achieved by determinising automata
whenever necessary. However, this might not be the best technique, as
determinisation can be exponential in the size of the automaton, and system
automata are likely to be very large. Part of the contribution of this paper is
therefore a technique to avoid generating non-deterministic system automata
altogether.

\paragraph{Control Automata.}

Control automata are automata that can express on the one hand the application
of a rule and on the other the observation that a given set of rules cannot be
applied. The latter is called a \emph{failure}. The set of all possible
failures is given by $\Fail = 2^{\Rule}$.
%
\begin{definition}[control automaton]
  A \emph{control automaton} is an automaton where $\Sigma = \Rule \cup \Fail$,
  such that:
\begin{itemize}
\item For all $q\in Q$, $q \arrow{F}$ with $F\in \Fail$ only if $\forall a
  \in F : q \arrow{a}$.
\item For all $q\in S$, $a\in \Rule$, $F\in \Fail$ there is no transition $q\trans a$ or $q\trans F$.
\end{itemize}
\end{definition} 
%
The class of control automata is denoted $\CAut$. Note that the empty failure
represents the fact that all rules in the empty set are inapplicable, which is
vacuously true; hence, an empty failure transition is effectively a
$\lambda$-transition.
%
\begin{example}\label{ex:ca}
  Figure \ref{fig:ca_example} shows a control automaton in which rule
  $\propagate$ is scheduled as long as it is possible, after which $\dispatch$
  is scheduled. In the setting of Example \ref{ex:sa}, the door is closed only
  when no more passengers want to enter the train. Here, $c_0 \arrow{[e]} c_2$
  denotes a failure transition with label $\setof{e}$. $[]$ represents the empty failure, and has the same behaviour as a $\lambda$-transition.
\end{example}

\begin{figure}[tb]
\centering
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,auto,bend angle=45,semithick,>=stealth',initial text=]
\tikzstyle{every state}=[shape=circle,draw]
\node[state,initial]		(c0)							{$c_0$};
\node[state] 					(c1)	[right of=c0]		{$c_1$};
\node[state] 					(c2)	[below right of=c0]{$c_2$};
\node[state,accepting] 		(c3)	[right of=c2]		{$c_3$};
%\node[state,accepting](s2) [below right of=s0] {$s_2$};
%\node[shape=circle](s4) [right of=s2]{};
\path[->]
(c0) edge             node       {$\scriptstyle\propagate$}   (c1)
     edge             node[swap] {$\scriptstyle[\propagate]$} (c2)
(c1) edge[bend right] node[swap] {$\scriptstyle{[]}$}         (c0)
(c2) edge             node       {$\scriptstyle\dispatch$}    (c3);
\end{tikzpicture}
\caption{Example Control Automaton}
\label{fig:ca_example}
\end{figure}
%
\subsection{Combining System Behaviour and Control}

The idea of a failure as the observation of a set of rules being inapplicable
is given a meaning by defining the product of control and system automaton.
This results in another system automaton, where states are tuples of a system
state and a control state.

\begin{definition}[product]\label{def:prod}
The \emph{product} of a system automaton $\cA$ and a control automaton $\cC$ is
defined as $\cA\times \cC = ( Q_\cA \times Q_\cC, \Sigma_\cA, \rightarrow,
(q_{0,\cA},q_{0,\cC}),  S_\cA \times S_\cC)$, where the transition relation is defined by the following rules:
% \begin{itemize}
% \item $Q = Q_\cA \times Q\cC$;
% \item $q_0 = (q_{0,\cA},q_{0,\cC})$;
% \item $S = S_\cA \times S_\cC$.
% \end{itemize}
% %
% The transition relation is defined by the following rules:
%
\begin{equation*}
\frac
{q_\cA \arrow{n,i}_\cA q_\cA' \quad q_\cC \arrow{n}_\cC q_\cC'}{
(q_\cA,q_\cC) \arrow{n,i} (q_\cA',q_\cC')}
\qquad
\frac
{q_\cC \arrow{F}_\cC q_\cC' \quad \forall n \in F, k \in {\tt Id}: q_\cA \narrow{n,k}_\cA}
{(q_\cA,q_\cC) \arrow{\lambda} (q_\cA,q_\cC')}
\end{equation*}

\begin{equation*}
\frac
{q_\cA \arrow{\lambda}_\cA q_\cA'}
{(q_\cA,q_\cC) \arrow{\lambda} (q_\cA',q_\cC)}
\end{equation*}
\end{definition}

The control automaton constrains the system automaton on the name-component of its traces. In particular, in a combination of system state and a certain control state, a failure transition from that control state can be taken when for none of the names in the failure set an outgoing rule application exists in the system state. Because a failure transition in the control automaton results in a $\lambda$-transition in the product automaton, the alphabet of the product is the same as the input system automaton.

\begin{figure}
\centering
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,auto,bend angle=45,semithick,>=stealth',initial text=]
\tikzstyle{every state}=[shape=circle,draw]
\node[state,initial] 		(s0c0)							{$s_0,c_0$};
\node[state] 					(s1c1)	[below of=s0c0]	{$s_1,c_1$};
\node[state] 					(s1c0)	[right of=s0c0]	{$s_1,c_0$};
\node[state]					(s2c1)	[below of=s1c0]	{$s_2,c_1$};
\node[state]					(s2c0)	[right of=s1c0]	{$s_2,c_0$};
\node[state]					(s2c2)	[right of=s2c0]	{$s_2,c_2$};
\node[state,accepting]		(s5c3)	[below of=s2c2]	{$s_5,c_3$};
%\node[state,accepting](s2) [below right of=s0] {$s_2$};
%\node[shape=circle](s4) [right of=s2]{};
\path[->]
(s0c0)	edge		node 	[swap]{$\scriptstyle \propagate,0 $}	(s1c1)
(s1c1)	edge		node 			{$\scriptstyle\lambda$}				(s1c0)
(s1c0)	edge		node	[swap]{$\scriptstyle\propagate,1$}	(s2c1)
(s2c1)	edge		node			{$\scriptstyle\lambda$}				(s2c0)
(s2c0)	edge		node			{$\scriptstyle\lambda$}				(s2c2)
(s2c2)	edge		node	[swap]{$\scriptstyle \dispatch,0$}		(s5c3);
\end{tikzpicture}
\caption{Example Product System Automaton}
\label{fig:prod_example}
\end{figure}

For example, Figure \ref{fig:prod_example} shows the system automaton that is the product of the system and control automaton in Figures \ref{fig:sa_example} and \ref{fig:ca_example}.
