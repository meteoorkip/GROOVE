\documentclass[a4paper]{article}
\usepackage{xspace}
\usepackage{graphics}
\usepackage{times}
\usepackage{amsmath}
\usepackage{groove2tikz}

\newcommand{\GROOVE}{\textsc{groove}\xspace}
\newcommand{\append}{\textsf{append}\xspace}
\newcommand{\nextR}{\textsf{next}\xspace}
\newcommand{\appendR}{\textsf{append}\xspace}
\newcommand{\stopR}{\textsf{stop}\xspace}
\newcommand{\returnR}{\textsf{return}\xspace}

\newcommand{\showgraph}[3]{
    \multicolumn{1}{c}{\framebox[#1cm]{\rule{0pt}{#2cm}\input{fig/#3.tikz}}}
}
\begin{document}
\title{State space of the \append rule system}
\author{Arend Rensink}
\date{November 2010}
\maketitle
\begin{abstract}
In this note we analyse the state space of the \textsf{append} rule system, and
we give a combinatorial formula for the state space size for a set of start
states.
\end{abstract}

\section{Introduction}

One of the performance tests used in \GROOVE (and reported in, e.g.,
\cite{SchmidtRenVar2004,Rensink2007}) is the \append rule system. This models a
concurrently invoked method that appends an element to a list by recursively
calling itself on each successive element until it reaches the end of the list,
at which point it extends the list and returns. The system consists of the four
rules displayed in \ref{f:append-rules}.

\begin{figure}
\begin{center}
\begin{tabular}{ll}
\nextR: & \appendR: \\
\showgraph{6}{4.3}{next} & 
\showgraph{5}{4.3}{append} \\[\medskipamount]
\stopR: & \returnR: \\
\showgraph{6}{2.5}{stop} & 
\showgraph{5}{2.5}{return}
\end{tabular}
\end{center}
\caption{Rules of the \append transformation system}
\label{f:append-rules}
\end{figure}

It should be noted that this rule system uses neither typing nor flags. The
meaning of the rules is as follows:
\begin{description}
\item[\nextR] recursively invokes \append on the next cell of a list. The
  value to be appended is pointed to by the \textsf{x}-edge. Due to the
  negative application condition, the rule is only applicable if the next list
  cell does not contain the value to be appended.

\item[\appendR] creates a new list cell and gives it the indended value
  (through a \textsf{val}-edge). Control returns to the caller by giving it a
  reaturn value (the node labelled \textsf{void}).

\item[\stopR] stops the traversal of the list, in case the next list element
  contains the value that is to be appended. Control returns to the caller, in
  the same way as for the \appendR rule.

\item[\returnR] ends a method that has a return value (which must have
  been inserted by a recursively called sub-method), by passing on the return
  value to the caller.
\end{description}

Depending on the number of concurrent invocations, the state space can quickly
grow large: the size is exponential in the number of \appendR-invocations,
where the base is (essentially) the length of the list. The quickly growing
size is why we have used thi rule system as a test case for \GROOVE, both for
correctness and for performance.

However, in order to legitimately use the rule system for testing the
correctness of \GROOVE, we need an independent means of determining the correct
outcome. For that purpose, in this note we derive formulas for the state and
transition counts of the state spaces generated for a certain class of state
graphs. Typicalstart graphs are shown in Figure~\ref{f:append-start-graphs}.

\begin{figure}
\centering
\begin{tabular}{l}
Length 5, append 2 (no sharing): \\
\showgraph{11}{4}{append-2-list-5} \\
Length 5, append 3 (list sharing): \\
\showgraph{11}{4}{append-3-list-5-share} \\
Length 5, append 3 (call sharing): \\
\showgraph{11}{4}{append-3-list-5}
\end{tabular}
\caption{Typical start graphs for the \append rule system}
\label{f:append-start-graphs}
\end{figure}

\section{Analysis of the state space}

We investigate three different scenarios for the \append system:
\begin{description}
\item[No sharing.] This refers to a start graph with (initially) two concurrent
  \append invocations, where the elements being appended are not already in the
  list and are not the same for both methods. An example (with list size 5) is
  the first graph in Figure~\ref{f:append-start-graphs}.

\item[List sharing.] This refers to a start graph where there is an \append
  invocation attempting to append an element that is already in the list. This
  will not succeed: the method wil be aborted by the \stopR-rule, and have no
  effect on the list. An example is the second graph in
  Figure~\ref{f:append-start-graphs}.

\item[Call sharing.] This refers to a start graph where two \append invocations
  attempt to append the same element (which is not already in the list). In
  this case the first invocation to reach the end of the list will succeed in
  appending the element; the second invocation will then abort (with the
  \stopR-rule) because the element is already present. An example is the third
  graph in Figure~\ref{f:append-start-graphs}.
\end{description}

\subsection{No sharing}

In the scenario without sharing, we invoke 2 concurrent instances of \append on
a list of varying length; the elements to be appended are neither in the list
nor shared among the two invocations. Figure~\ref{f:lts} shows the state space
for a list of length 5 (for the start graph in
Figure~\ref{f:append-start-graphs}). The initial state is on top; there are two
final states, namely the two bottom corners. Clearly, the state space is
nondeterministic: there is a choice in which of the append methods ``wins'' in
making it to the end of the list and appending its element first. Apart from
this choice, all transformations are (locally) confluent.

\begin{figure}
\centering
\scalebox{.3}{\input{fig/lts.tikz}}
\caption{State space of 2 concurrent appends on a list of length 5}
\label{f:lts}
\end{figure}

\begin{align*}
s_1: x & \mapsto 5x^2 + 4x \\
t_1: x & \mapsto 10x^2 + 2x - 4 \\[\medskipamount]
s_2: x & \mapsto 2i\, s_1(x) 
       & i \mbox{ is the position of the shared list node} \\
t_2: x & \mapsto 2i\,t_1(x) + (2i-1)s_1(x) \\[\medskipamount]
s_3: x & \mapsto {11x^3 + 31x^2 + 20x \over 2} \\
t_3: x & \mapsto 3s_3(x) - {19x^2 + 49x + 22 \over 2}
\end{align*}

\section{Conclusion}

The analysis reported in this note was inspired by the observation that the
current version of \GROOVE reports different values for the transition count of
the \append state spaces than the one listed in \cite{SchmidtRenVar2004}.
Clearly one of the versions has to be erroneous. Our analysis shows that it was
the past version, and not the current one, that is wrong: in particular, the
transition counts (but not the state counts) in Table~2 of that paper differ
from Table~\ref{t:results} (they are too high), whereas the current \GROOVE
version generates precisely the numbers in the table. We do not have a
hypothesis regarding the source of the error.
%
\bibliographystyle{abbrv3}
\bibliography{local}
\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
