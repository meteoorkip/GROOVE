% -----------------------------------------------------------------------------
% 3-problem.tex
% -----------------------------------------------------------------------------

\section{Application to Feature Modelling}
\stlabel{problem}

Feature models \cite{Kang1990} are commonly used to support the configuration
of products in software product lines \cite{Pohl2005}. They model variability
by expressing commonalities, variations and constraints between the different
features that could be part of a product. A feature usually represents an
aspect of the software in an early phase of the software life cycle, and the
impact of the combination of features is propagated across the phases until the
actual product is implemented.

The analysis of feature models \cite{Benavides2005,Broek2009} is mostly
concerned with verifying their static properties with respect to allowed
specifications and valid configurations of the model. However, the
specification of feature models and their configuration process go beyond the
information in the model: they often involve multiple groups with distinct
interests and expertise, which informally express extra properties of the
features. Moreover, the definition of possible products depends on forces like
market demands, user preferences, and the availability of assets at a specific
time (such as the software components for the related products). Thus, feature
modelling is a domain which can strongly profit from the ability to define and
query static and dynamic properties of models, leading to richer analysis
techniques. In particular, we can identify the following tasks in the analysis:
%
\begin{enumerate}\noitemsep\label{options}
\item Model additional knowledge about features;
\item Define domain properties independently on the models, in a declarative
  way;
\item Simulate the configuration process;
\item Query for valid configurations with respect to conditions not expressed
  in the feature model;
\item\label{staged} Analyse alternative configuration paths and investigate the
  evolution of configuration stages.
\end{enumerate}
%
We proceed to show how the \Prolog extension for \GROOVE can be used to
implement these tasks. First we give an overview of the relevant concepts in
terms of a type graph, some example rules and a small example model; then we
focus on the use of \Prolog to query the resulting state space of the grammar.
