% -----------------------------------------------------------------------------
% 4-solution.tex
% -----------------------------------------------------------------------------

% \section{\GROOVE Solution}
% \stlabel{solution}

% %
% %%% Local Variables:
% %%% mode: latex
% %%% TeX-master: "main"
% %%% End:
% %
% In this section describe the \GROOVE solution for the feature modelling and configuration case. We use as example a feature model that partially represents the features of a software product line for home automation. 

\subsection{Feature Model Type Graph}

\begin{figure}[tb]
\centering
\inputtikz{featuretype.tikz}
\caption{A type graph for feature models.}
\flabel{featuretype}
\end{figure}

\fref{featuretype} shows a type graph for feature models (in \GROOVE), based on
the definitions given in \cite{Broek2009}. The type \type{FeatureModel}
represents a feature model composed of two parts: a \type{FeatureTree} whose
nodes represent \typeX{Feature}s, and a set of explicit \typeX{Constraint}s
between these features. The constraint \type{Requires} indicates that if the
target node of \lab{feature1} is selected for a product, then the target node of
\lab{feature2} should be selected as well. The constraint \type{Excludes}
indicates that the target nodes of \lab{feature1} and \lab{feature2} cannot be
both selected for the same product.
Type \type{Feature} has three subtypes: \type{MandOpt}, \type{Or} and
\type{Alt}. The edges from each of these subtypes to a \type{Feature} indicate
which kinds of child features each subtype can have. Leaf features of the tree are \type{MandOpt} features without children.
Finally, the flags \flag{configured}, \flag{violated}, and \flag{selected} in
the type graph are used in GT rules to assist the configuration process and to
enforce the identification of valid configurations.

\subsection{Product Configuration}

A specific feature model is a graph instantiating \fref{featuretype},
initially without any flags. The model is then configured using GT rules that
encode the following constraints (some of which were discussed above):
%
\begin{enumerate}
\item The root feature must be selected first;
\item When a \type{MandOpt} is selected, all \lab{mandatory} children
  must also be selected;
\item When an \type{Or} is selected, at least one of its children must also be
  selected;
\item When an \type{Alt} is selected, exactly one of its children must also be
  selected; 
\item When a non-root feature is selected, its parent feature must also be
  selected.
\end{enumerate}
%
Child features are selected on demand and violations of constraints are checked
at each step. This applies both to the implicit conditions of the
\type{FeatureTree} and to the explicit \type{Requires} and \type{Excludes}
constraints in the model.

\begin{figure}[t]
\centering
  \subfigure[]{\flabel{graphrules-a}
  \inputtikz{ViolationSelectionChildOrFeature.tikz}}
  \hspace{1ex}
  \subfigure[]{\flabel{graphrules-b}
  \inputtikz{ValidationRequiresConstraint.tikz}}
  \hspace{-3ex}
  \subfigure[]{\flabel{graphrules-c}
  \inputtikz{FeatureModelConfiguration.tikz}}
\caption{Examples of graph production rules for feature model configuration.
\GROOVE rules are represented in a single graph, with different colours and
line strokes used to distinguish different elements: black (continuous thin)
elements are matched and preserved, and red (dashed fat) elements are Negative
Application Conditions (NACs). Node flags preceded by a character have especial
roles: $+$ indicates flag creation; $-$ is flag deletion, and $!$ is a NAC on
the flag.}
\flabel{graphrules}
\vspace{-6pt}
\end{figure}

Each of the steps above is performed by a combination of graph transformation
rules. For example, \fref{graphrules-a} shows a rule used to detect a violation
on the selection of a child feature of an \type{Or} (step~3); the rule in
\fref{graphrules-b} selects a feature which is required by another, previously
selected one and removes the violation of the \type{Requires} constraint; and
the rule in \fref{graphrules-c} checks the conditions for the complete feature
model to be correctly configured and marks it as \flag{configured}. A valid
configuration of the feature model is found when neither the constraints nor the
feature tree are violated. Note that a tree violation is modelled independently
of the violation of explicit constraints between pair of features. A tree has a
violation when one of the requirements listed above is not satisfied, \eg, when
the root feature is not selected. Each valid configuration selects a set
of features that gives rise to a potential product of the product line.

Starting from the initial feature model, state space exploration generates a GTS
resulting from all possible interleavings of rule applications. Each state
represents the feature model with a partial selection of features, some of which
may form valid configurations. \fref{featuremodel} shows a completely configured
feature model, immediately after the application of the rule shown in
\fref{graphrules-c} (named \lab{FeatureModelConfiguration} in the grammar). This
configuration has a set of \flag{selected} features and no constraint violations
(\flag{violated} flags). Note that the mandatory part of feature
\feat{EnergySaving} does not have to be selected since the feature itself, which
is optional, was not selected. Once generated, the GTS can be queried using
\Prolog.

\begin{figure}[t]
\centering
\inputtikz{featuremodel.tikz}
\caption{A valid configuration of the feature model.}
\flabel{featuremodel}
\end{figure}

\subsection{Querying the State Space}
\stlabel{query}

We now come to the main point of the example, which is how \Prolog may be used
to analyse the state space. For instance, the following user-defined predicate
extracts completely configured products:
%
\prolst{21}{26}
%
The predicate searches for graphs resulting from the application of rule
\lab{FeatureModelConfiguration} and then collects all selected features in this
graph (using \inPro{findall}, which is a higher-order predicate provided by GNU
\Prolog). Successive calls of \inPro{product} generate all valid models. For the
initial, unconfigured version of the feature model this yields 50 products,
including the one shown in \fref{featuremodel} (composed of features
\feat{HomeAuto}, \feat{Surveil}, \feat{AccidentDet}, \feat{AlarmAuto},
\feat{Alarm}, and \feat{Bell}). Predicate \inPro{product} uses the following
auxiliary predicate, which consults information of the GTS.
%
\prolst{4}{10}
%
This predicate uses the rule application event associated with transitions of
the GTS to ensure that the given rule is the one that was indeed applied in the
\inPro{Transition}.
%
It is important to note that the GTS has a total of 312 states, representing all
intermediate states that lead to one of the 50 configured feature models. These
intermediate states allow the analysis of different evolution paths (formed by
different rule application sequences) that lead to the same solution.
Furthermore, the grammar contains rules to re-validate constraint violations,
making it possible to reach a valid configuration even if a constraint was
violated in an intermediate state.

\medskip\noindent Another useful capability provided by the \Prolog extension
is the possibility to define a knowledge base of additional model-related
information. As an example, suppose that we are interested in products that
satisfy a certain budget constraint. The following \Prolog code sets the costs
for each feature of the model and defines what it means for a product to be
within budget.
%
\prolst{28}{39}
%
The following query returns products with total cost smaller or equal to 70:
\begin{lstlisting}[style=prolog]
?- product(P), within_budget(70, P).
\end{lstlisting}
%
For our running example, this gives 11 products within the budget constraint.
