\section{Graph-based state space generation}
\stlabel{groove}

Graph transformation is a declarative formalism, based on a set of \emph{rules}
that are applied to \emph{graphs}. In the context of this paper, graphs are
edge-labelled, with labels drawn from a global set $\Lab$; moreover, nodes are
drawn either from a set of node identities $\Node$, or from the set of
primitive data values $\Val=\Bool\cup \Int\cup \Real\cup \String$.

\begin{definition}[graph, isomorphism]\dlabel{graph}
  A graph $G$ is a tuple $\tup{V,E}$ where $V\subseteq \Node$ is a finite set
  of nodes and $E\subseteq V\times \Lab\times (V\cup \Val)$ is a finite set of
  edges. We use $\src(e)$, $\tgt(e)$ and $\lab(e)$ to denoted the source,
  target and label of an edge $e$. The set of all graphs is denoted $\Graph$.
  Graphs $G,H$ are \emph{isomorphic}, denoted $G\iso H$, if there exists a
  bijection $f\ftype{V_G}{V_H}$ such that $(f(v),a,\bar f(w))\in E_H$ if and
  only if $(v,a,w)\in E_G$, where $\bar f=f\cup\id_\Val$. We sometimes write
  $f(G)=H$.
\end{definition}
%
There is no need to precisely define rules; we merely formalise their actions
upon graphs. A rule is an object $r$ that can be applied to a \emph{host graph}
$G$ if there exists a so-called \emph{match} $m$ for $r$ in $G$ (not formalised
here, either).  The rule and the match together determine a transformation of
$G$, formally expressed by a derivation relation $G\trans{r,m} H$, where $H$ is
called the \emph{target graph}. This derivation relation is well-defined and
deterministic modulo isomorphism:

\begin{itemize}\noitemsep
\item $G\trans{r,m} H$ and $G'\iso G$ implies $G'\trans{r,m} H'$ for some
  $H'\iso H$.
\item $G\trans{r,m} H_1$ and $G\trans{r,m} H_2$ implies $H_1\iso H_2$.
\end{itemize}
%
Using these concepts we define the graph transition system
generated by a set of rules.

\begin{definition}[graph transition system]\dlabel{GTS}
  The graph transition system (GTS) for a set of rules $R$ and a start graph $S$ is
  given by $\tup{Q,{\ra},S}$, where $\ra$ is the derivation relation
  restricted to $Q$, and $Q$ is the smallest set of graphs such that (i) $S\in
  Q$, and (ii) $H\in Q$ for all $G\in Q$, $r\in R$ and $G\trans{r,m} H$.
\end{definition}
%
The GTS is a labelled transition system as used in many verification methods,
in particular model checking \cite{BaierKat2009}.  Unfortunately, the GTS can
easily be infinite, and even when finite can grow extremely large even for
small start graphs --- a phenomenon called \emph{state
  space explosion}. One way to combat state space explosion is through
\emph{symmetry reduction} (see, e.g., \cite{Clarke+1996}). In the case of
graphs, symmetries show up as isomorphisms; the state space can be reduced by
collapsing all isomorphic states, or in other words, taking the quotient of the
GTS under $\iso$. The following algorithm generates this quotient $\tup{Q,T,S}$
(where $T$ is the set of transitions).
%
\begin{quote}
\begin{lstlisting}[keywords={while,endwhile,if,then,else,endif,let,do,choose,for,endfor},numbers=left]{}
let `$Q := \set{S}, \enspace T := \emptyset, \enspace F := \set{S}$
\qquad \textrm{($F$ is the collection of fresh states)}`
while `$F\neq\emptyset$`
do choose `$G\in F$ \qquad \textrm{(which $G$ is chosen depends on the structure of $F$)}`
   let `$F := F\setminus \set{G}$`
   for `$G\trans{r,m} H$`
   do if `$\exists H'\in Q: H'\iso H$\label{iso-check}`
      then let `$H := H'$`
      else let `$Q := Q\cup \set{H}, \enspace
                 F := F\cup \set{H}$`
      endif
      let `$T := T\cup\set{(G,r,m,H)}$`
   endfor
endwhile
\end{lstlisting}
\end{quote}
%
The crux is in Line~\ref{iso-check}, which tests for
\emph{membership up to isomorphism}: given a graph $H$ and a set of graphs
$Q$, find $H'\in Q$ such that $H'\iso H$. Testing $H'\iso H$ for given graphs
$H,H'$ is believed to be non-polynomial in $|H|$ (see \cite{Weisstein2002}),
and clearly membership up to isomorphism generalises the pairwise test.
However, we have shown in \cite{Rensink2006,CrouzenPolRen2008} that the gain by
symmetry reduction can be huge, and hence can be worthwhile despite its
complexity. We now discuss two ways to implement membership modulo isomorphism.

\vspace*{-\medskipamount}
\paragraph{Graph certificates.}

The current implementation of \GROOVE, as reported in \cite{Rensink2006}, uses
\emph{certificates} to obtain a data structure for $Q$ allowing a
membership-up-to-isomorphism test that performs well in many practical cases.

A \emph{node certifier} is a function $\nc\ftype\Graph{\Node\pfunc\Nat}$, which
for every graph $G$ results in a function $\nc_G\ftype{V_G}\Nat$ with the
property that $\nc_G=\nc_H\circ f$ for all isomorphisms $f$ from $G$ to $H$. A
\emph{graph certifier} is a function $\gc\ftype\Graph\Nat$ such that $G\iso H$
implies $\gc(G)=\gc(H)$. An easy example of a node certifier is to count the
number of incident edges ($\nc_G\colon v\mapsto |\genset{e\in E_G}{\src(e)=v
\vee \tgt(e)=v}|$ for all $v\in V_G$). Every node certifier $\nc$
gives rise to a graph certifier $\gc\colon G\mapsto \sum_{v\in V_G} \nc(v)$.

\GROOVE currently implements $Q$ as a map $\Nat \func \powerset\Graph$
such that $n\mapsto \genset{G\in Q}{n=\gc(G)}$. Finding $H'\in Q$ such that
$H'\iso H$ comes down to searching $Q(\gc(H))$, which for a good graph
certifier $\gc$ is almost always either empty or a singleton set. Moreover,
pairwise testing $H'\iso H$ for the $H'\in Q(\gc(H))$ is made easier by using a
node certifier.

\vspace*{-\medskipamount}
\paragraph{Canonical forms.}

One can take the idea of graph certifiers one step further by also requiring
that $\gc(G)=\gc(H)$ implies $G\iso H$. This is the idea behind the concept of
\emph{canonical forms}.

A \emph{graph canoniser} is a function $\can\ftype\Graph{\Node\pfunc \Node}$,
which for every graph $G$ results in an injective function
$\can_G\ftype{V_G}{\Node}$ such that $G\iso H$ if and only if
$\can_G(G)=\can_H(H)$. (Note that, in combination with a hash function
$\hash\ftype\Node\Nat$, this gives rise to a node certifier $\nc=\hash\circ
\can$.) $Q$ can then be implemented as a set of canonical form graphs.
Obviously, computing canonical forms is as complex as testing for isomorphism;
nevertheless, in practice the complexity often turns out to be bearable. In
particular, the algorithm developed by McKay \cite{McKay1981} as implemented in
the tools \NAUTY \cite{NAUTY} and \BLISS \cite{BLISS} does well in practice.

We have used \BLISS in our experimentation in the distributed setting.
There is a discrepancy in that
\BLISS uses node-labelled rather than edge-labelled graphs; however, our graphs
can be converted to \BLISS graphs without loss of information, though with a
slight blowup due to the need to encode edge labels in some way. Another
noteworthy property is that the canonical forms produced by \BLISS always map
to an initial fragment of $\Nat$; that is, $\can_G(V_G)=\set{0,\ldots,|V_G|-1}$
for all graphs $G$.
\BLISS reorders the nodes such that for isomorphic graphs $G$ and 
$H$ for all $v \in G$ the same number is assigned to $v$ and $f(v) \in H$ for some 
isomorphism $f$ (with $H=f(G)$).

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
