\section{The \textsc{\bfseries LTSmin} framework}
\stlabel{ltsmin}

\LTSMIN is meant to be used as a module in a tool chain that enables state
space generation on parallel or distributed systems, consisting of many
independent cores. The modular design ensures that the framework can be used
for a variety of formalisms. The communication between \LTSMIN and the
application that uses it, hereafter called the \emph{user module}, is through an interface called \PINS, for \emph{Partitioned
  Next-State function}. We will briefly explain the underlying concepts.

To run an application on top of the \LTSMIN framework, an \LTSMIN client as
well as a copy of the user module is started up in parallel on every
core. These copies communicate by message passing, so that it does not
matter (from the protocol view) whether cores are on a single machine or
distributed over different machines. State space exploration then proceeds as
follows:

\begin{itemize}\noitemsep
\item \LTSMIN defines a function that associates a fixed core with each state,
  on the basis of the state's vector representation. When a state is generated,
  it is sent to the associated core for further processing. The exploration is
  kicked off by sending the initial state to the appropriate core.
\item Each core keeps a store of all states sent to it so far, remembering also
  whether the states are closed (i.e., already fully explored) or fresh.
\item Upon reception of a state, a core adds it to its state store, marking it
  as fresh if it was not already in the store.
\item Each core computes the successor of each fresh state, and sends the
  successors to their associated cores. This computation is done by the user
  module.
\end{itemize}%
%
An example configuration with
\GROOVE and \BLISS is depicted schematically in \fref{ltsmin}.

\texfig{ltsmin}{3-core configuration of \LTSMIN with \GROOVE+\BLISS as user module.}

\subsection{State vectors and tree compression}

The central concept enabling the modularity of \LTSMIN is the \emph{state
vector}. Every state has to be presented as a vector $\tup{p_1,\ldots,p_n}$ for
fixed $n$. The nature of the elements $p_i$ actually does not matter, as these
are immediately mapped to table indices for each position.  That is, for
$i=1,\ldots,n$ \LTSMIN builds up an injective mapping $t_i\ftype{P_i}\Nat$,
where $P_i$ is the set of all values encountered so far at position $i$ and
$\Nat$ is a finite fragment of natural numbers; e.g., that fragment which can
be represented in 32 bits. Every state vector $\tup{p_1,\ldots,p_n}$ is then
converted to an \emph{index vector} $\tup{t_1(p_1),\ldots,t_n(p_n)}\in \Nat^n$.
The mappings $t_i$ are generated on the fly: once a value is encountered for the first time 
(on position $i$) it is added to $t_i$; 
from then on the same value on that position will always be mapped to the same index.
The function associating a core with each state is computed as a hash on the
index vector, modulo the number of available cores.

The tables $(t_i)_{1\leq i\leq n}$, together called the
\emph{leaf database}, are duplicated in the system. It is
essential that all workers use the same tables, but they are impossible to
build beforehand, as it is unknown which values will be encountered at each
position. For this reason, the \LTSMIN framework also has the task of
distributing the tables over the workers, which in turn means that all the
$t_i$ are replicated over all \LTSMIN clients. On the other hand, the tables
also need to be known on the side of the user module, since this is where the
coding of state vectors to and from index vectors actually takes place. Thus,
in a system with $c$ cores, all $t_i$ are replicated $2c$ times.\footnote{This
  description is actually still slightly simplified with respect to the
  implementation: there the encoding of the \emph{outgoing} states may be
  different from that of the \emph{incoming} ones; the former is then local to
  each core, and the \LTSMIN clients translate the local to the global
  encoding.}

Index vectors are further compressed using so-called \emph{tree compression}
(see \cite{Blom+2008}): without going into details, this comes down to
repeatedly grouping neighbouring positions of the index vector and building a
new table of all combinations of values at those positions that are found
during exploration. All these tables together form what is called the
\emph{tree database}.

The success of the method crucially depends on finding a state vector
representation that has as few values at each vector position as possible;
i.e., each of the $P_i$ should be small. This does not contradict a huge
overall state space size: for $\max_i |P_i|=m$, the number of states that can
potentially be represented is $m^n$. In the worst case, for one or more $i$
$|P_i|$ approaches the total state space size, and hence so does the size of
the tree database; the advantage of this compression method is then completely
lost.

\subsection{Serialising canonical form graphs}

We will now describe the steps necessary to use \GROOVE as a user module in the
\LTSMIN framework. The main difficulty is to find a suitable state vector
representation. This is entirely up to the user module: \LTSMIN gets to see the
state vectors only after they have been produced, and treats the values in the
$P_i$ as completely unstructured.

It is absolutely necessary that the state vectors uniquely represent
states. This means that, if we want to benefit from symmetry reduction, we have
to put graphs into canonical form \emph{before} communicating them to
\LTSMIN. Moreover, as explained above, the vector representation should ideally
have only few possible values at each slot.

In \stref{groove} we have explained that the canonical form computed by \BLISS
essentially assigns a sequence number from $0$ to $|V|-1$ to each node of a
graph $G$.
This imposes a total ordering $\leq$ on $V$; we will use $\vec
v=v_0\cdots v_k$ to denote the ordered sequence of nodes in $V$. Furthermore,
we use the natural total orders on the primitive values $\Int$, $\String$,
$\Bool$ and $\Real$ and we assume a total order on $\Lab$ (for instance, the
alphabetical ordering). This also gives rise to a lexicographical ordering on
edges. In the sequel, $\ord(X)$ for a set $X$ with an implicit order will
denote the ordered vector of $X$-elements, and $\vec x\restriction_I$ for a
sequence $x\in X^*$ and an index set $I\subseteq \set{0,\ldots,|\vec x|-1}$
will denote the sequence of elements at positions $I$.

The vector $\vec p_G$ representing $G$ will consist of $n$ slots, of which the
first contains a sequence of \emph{node colours} 
(i.e., the primitive value in the case of value nodes or the set of self-edges for 
the other nodes; this is also used in the conversion to coloured graphs, needed for the use of \BLISS), 
one for each node, in the order
imposed by the canonical form; the second to fifth contain the sets of
primitive values from $\Val$ used as target nodes, seperated per primitive
type; and the remaining slots contain outgoing edges for the individual
nodes. If $k>n-5$ (where $k=|V_G|$ and $n=|\vec p|$) then nodes are ``wrapped
around'', e.g.\ for $n=12$ slot $p_5$ would be used for $v_0, v_7, v_{14},
\ldots$. 
This way graphs can be encoded into a fixed size vector, 
even if the size of the graphs is not fixed.
Formally this is defined by 
%
\[ 
p_i = \begin{cases}
\col_G(v_0)\cdots \col_G(v_k)
 & \mbox{if $i=0$}
 \\[-\smallskipamount]
\X_G
 & \mbox{if $i=1+j$ and $\X=(\Int\;\String\;\Bool\;\Real)\restriction_j$}
 \\[-\smallskipamount]
\out_G(w_0) \cdots \out_G(w_m)
 & \mbox{if $i=5+j$ and $\vec w=\vec v\restr\genset{l}{l=j\mathbin{\mathrm{mod}}(n-5)}$}
\end{cases}
\]
%
where $\col_G(v)$ denotes the colour and $\out_G(v)$ the outgoing edges of
$v$, defined as follows:
%
\begin{align*}
\col_G(v)
 & = \left\{\begin{array}{@{}ll}
       \self_G(v) & \mbox{if $v\in \Node$} \\
       (\X,i) & \mbox{if $v=\X_G\restriction_i$},
     \end{array}\right.  \\
\self_G(v)
 & = \genset{a}{(v,a,v)\in E_G}, \\
\X_G
 & = \ord(\X\cap \tgt(E_G))
     \qquad \mbox{for $\X=\Int,\String,\Bool,\Real$}, \\
\out_G(v)
 & = \genset{(a,\can_G(w))}{(v,a,w)\in E_G, v\neq w}.
\end{align*}
%
\begin{figure}
\begin{center}
\begin{tabular}{@{}p{4cm}p{10cm}}
\begin{center}
\renewcommand{\userdefinedmacro}{
\node [above=.1 of n0] {\rm\textit{0}};
\node [below=.1 of n1] {\rm\textit{1}};
\node [above=.1 of n2] {\rm\textit{2}};
\node [above=.1 of n3] {\rm\textit{3}};
\node [above=.1 of n4] {\rm\textit{4}};
\node [below=.1 of n5] {\rm\textit{5}};
}
\vspace*{-5mm}
\input{\figdir/vector-data-nodes.tikz}
%  \linebreak
% \small{$\can_G\colon \begin{array}[t]{@{}r@{{\;\mapsto\;}}l}
% \mathsf{3} & \mathit{3} \\
% \mathsf{-10} & \mathit{4} \\
% \mbox{\textsf{``hi''}} & \mathit{5}
% \end{array}$}
\end{center}
&
$\begin{array}[t]{l@{{\;=\;}}ll}
p_0 & \set{\mbox{\textsf{\bfseries A}}}\;
      \set{\mbox{\textsf{\bfseries A}}}\;
      \set{\mbox{\textsf{\bfseries B}}}\;
      (\Int,1)\;(\Int,0)\;(\String,0) 
    & \mbox{list of nodes} \\
p_1 & \mathsf{-10} \; \mathsf{3} 
    & \mbox{list of $\Int$s} \\
p_2 & \mbox{\textsf{``hi''}}
    & \mbox{list of $\String$s} \\
p_3 & \emptystr \quad\mbox{(the empty sequence)}
    & \mbox{list of $\Bool$s} \\
p_4 & \emptystr
    & \mbox{list of $\Real$s} \\
p_5 & \set{(\mathsf a,\mathit 2),(\mathsf b,\mathit 1),(\mathsf i,\mathit 3)} \;
      \emptyset
    & \mbox{edges of \textit 0 and \textit 4} \\
p_6 & \set{(\mathsf a,\mathit 2),(\mathsf i,\mathit 3)} \;
      \emptyset
    & \mbox{edges of \textit 1 and \textit 5} \\
p_7 & \set{(\mathsf i,\mathit 4),(\mathsf n,\mathit 5)}
    & \mbox{edges of \textit 2} \\
p_8 & \emptyset
    & \mbox{edges of \textit 3}
\end{array}$
\end{tabular}
\vspace*{-5mm}
\caption{An example graph with $|V|=6$, represented by a state vector with
  $|\vec p|=9$.
  The canonical node numbers are in italic. Node labels
  \textsf{\bfseries A}, \textsf{\bfseries B} are self-edges; oval nodes are
  data values.}
\flabel{vector}
\end{center}
\vspace*{-5mm}
\end{figure}%
%
An example state vector is shown in \fref{vector}. As related above, this is
translated to an index vector together with a set of tables $t_0,\ldots,t_n$,
so that a value at position $i$ which recurs in another state vector at the
same position is encoded by the same index. For instance, if the graph
in \fref{vector} is modified by $i:=3$ in node $0$, only slot
5 of the state and index vectors would change (namely to $\set{(\mathsf
  a,\mathit 2),(\mathsf b,\mathit 1),(\mathsf i,\mathit 4)}\;\emptyset$) and
only $t_5$ might have to be updated with this new value.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
