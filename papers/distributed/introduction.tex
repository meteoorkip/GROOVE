\section{Introduction}
\stlabel{introduction}

For the last two years, the development in modern computer processors has been
to put more cores on a single processor, rather than to speed up individual
cores. To benefit from this development, it is therefore important to find ways
to utilise the power of parallel processing. So far, there is no general way to
achieve this for arbitrary applications.

In the context of graph transformation, this topic has been investigated by
Bergmann et al.\ in \cite{BergmannRatVar2009} for the tool \VIATRA. The core
functionality of \VIATRA is to compute a sequence of transformations,
controlled by a predefined set of rules, as fast as possible. The paper
proposes parallellisation of the matching algorithm.

In this paper, we address parallellisation of \GROOVE \cite{GROOVE}, which
differs from other graph transformation tools in that it aims at \emph{complete
state space exploration} for a given set of rules, rather than computing a
single sequence --- where a state equates to a graph.  One of the most
important aspects of \GROOVE, furthermore, is that states are compared
\emph{modulo isomorphism}; that is, two graphs are considered to represent the
same state if they are isomorphic. Though checking graph isomorphism is thought
to be non-polynomial, the resulting reduction in state space size can more than
make up for the cost of isomorphism checking; see, e.g.,
\cite{CrouzenPolRen2008}.

At the core of our solution lies \LTSMIN \cite{BlomPolWeb2010},
an existing framework specifically designed to enable distributed state space
exploration with support for multiple specification languages.
To use \LTSMIN, an application has to:
%
\begin{enumerate}\noitemsep
\item Provide a serialisation of states in the form of fixed-length \emph{state
  vectors}. State vectors are minimised to so-called
  \emph{index vectors} (see \cite{Blom+2008}), which can be efficiently stored
  and transmitted.

\item Be able to generate all successors of a given source state,
  where both the source state and the successor states are communicated in the
  form of such a state vector.
\end{enumerate}
%
\LTSMIN will then run parallel copies of this application on every available
core; the copies communicate using message passing, so that this works equally
well with parallel and distributed cores. This method of parallellisation is
particularly promising for \GROOVE because the time-intensive step of
isomorphism checking is done concurrently for many states.

In the case of \GROOVE, Step~2 is present by default, but Step~1 is
challenging. It is not enough to ``flatten'' graphs to a vector representation
of some kind: in order to reduce the state space up to graph isomorphism, we
have to make sure that the representative vector is the same for isomorphic
graphs. For this purpose, we can make use of an existing tool called \BLISS
\cite{BLISS}, which computes \emph{canonical graphs} based on the principles
developed in \cite{McKay1981}. The \LTSMIN vector representing a graph is thus
the ``flattening'' of its canonical form.

\medskip\noindent We have experimented with this combination of \LTSMIN,
\GROOVE and \BLISS. In this paper we report two results:
\begin{itemize}\noitemsep
\item For larger cases, the time performance of the parallellised system scales
  well (though not linearly) with the number of processors. On a single core
  the setup is a good deal less efficient than \GROOVE, but a system with eight
  or more cores easily outperforms the stand-alone version of \GROOVE.

\item Given a good vectorisation of the canonical form, the memory performance
  of the combination of \LTSMIN, \GROOVE and \BLISS is also a good deal better than 
  that of the stand-alone version.
  This is surprising given the fact that, in contrast to \GROOVE, the data
  structures that \LTSMIN uses in its tree compression and central state store
  are not at all optimised towards the storage of graphs. The gain is large
  enough to make us consider moving to the compressed vector representation
  even in the stand-alone, sequential version.
\end{itemize}
%
We introduce \GROOVE in \stref{groove} and the relevant features of the \LTSMIN
framework in \stref{ltsmin}, especially the canonical graph vector
representation. In \stref{experiments} we report and analyze the outcome of the
experiments. \stref{conclusion} draws conclusions and discusses
future work.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
