\section{Assignment Featherweight Java with Around Advice}\label{sec:FAJ}

In this paper, we specify an operational semantics of Assignment Featherweight Java extended with the possibility of declaring \emph{around} advice. In this section, we describe the required background.\\

\subsection{The Featherweight AspectJ Language}
Featherweight Java (FJ) \cite{Igarashi99featherweightjava:} is a subset of Java that contains only five forms of expression: object creation, method invocation, field access, casting, and variables. Assignment Featherweight Java (AFJ) \cite{FJA} has extended this language with mutable field variables to bring it closer to the way Java programs are usually written. The minimal syntax and operational semantics make it a handy language for conceptual studies on the implications of language extensions. This makes the language useful for trying AOP language features. We actually study an extension of the AFJ language with around advice. For the duration of this paper, we will refer to the extended language as Featherweight AspectJ (FAJ).\\

\begin{figure}[ht]
\begin{align*}
Prog&::=\overline{L};e;\overline{A}\\
L&::= \textbf{class} \: T \: \textbf{extends} \: T \: \{ \overline{T\,f;} \: \overline{M} \}\\
M&::= T \: m(\overline{T \, x})\{e;\}\\
e&::= x \, \mid \, e.f \, \mid \, e.m(\overline{e}) \, \mid \, \textbf{new} \: T(\overline{e})\\
&\;\;\; \mid \, e.f=e \, \mid \, (T)e\\
A&::= T \: \textbf{around} (\overline{Tx}) \: : \: P \: \{e'\}\\
P&::= \textbf{call}(T^*.m^*(\overline{T^*}))\\
e'&::= e \: \mid \: e.\textbf{proceed}(\overline{e})\\
T^*&::= T \: \mid \: \textbf{*} \: \mid \: T+\\
m^* &::= m \: \mid \: \textbf{*}\\
\end{align*}
\caption{Grammar of Featherweight AspectJ.}
\label{fig:fja}
\end{figure}

The grammar of FAJ is shown in Figure \ref{fig:fja}. Throughout the paper we use the overbar notation for lists. A program consists of a set of classes, a main expression, and a set of advice declarations. Classes contain a list of field names and types, and a list of methods. A method consists of a return type, an identifier, a list of arguments and a method body, which is an expression. Expressions can be (from left to right) variables (e.g. a method parameters), fields accesses, method invocations with a sequence of expressions as arguments, object creations with a sequence of expressions as parameter, castings, assignments, and proceed expressions (see below). Object creation is not handled by an explicit constructor. Instead, the ordered list of arguments is assigned to the ordered list of fields.\\
Aspects are represented (global) declarations of an around advice and a point-cut. Advices, depicted in the grammar above by the letter $A$, are methods that can optionally contain a \emph{proceed} expression. As usual, we can use this also to mimic \emph{before} and \emph{after} advice, by adding a {\tt proceed} instruction after or before the instructions of the advice, respectively. An advice declarations is combined with a point-cut declaration (depicted by $P$ in the grammar) that selects certain expressions. In this language we have limited the point-cut language to selection of method calls. Such a point-cut is specified as a call to a certain receiver type $T^*$, which can be a concrete type, a wild-card, or $T+$, selecting a type and all its sub-types. The same is used for the parameters of the call. The method identifier can be either a concrete method identifier, or a wild-card selecting any identifier.\\

\begin{figure}[ht]
\begin{lstlisting}[language=FAJ]
class Exam extends Object {
   Nat grade;
   Nat setGrade(Nat n) { this.grade = n; }
}

class NamedExam extends Object {
   String name;
}

class Nat extends Object {
  // default implementation
  Nat add(Nat n) { n }
  Nat dec() { this  }
}

class Zero extends Nat {
  // zero can use default implementation 
}

class Succ extends Nat {
   Nat pred
   Nat add(Nat n) { new Succ(pred.add(n)); }
   Nat dec() { this.pred;  }
}
// scenario 1:
new NamedExam(new Zero()).setGrade(new Succ(new Succ(new Succ(new Succ(new Succ(new Zero())))));)
// scenario 2:
// new NamedExam(new Zero()).setGrade(new Zero())

// advice 1: extra point for filling in your name
Nat around(Nat n, NamedExam receiver) :
					call(NamedExam.setGrade(Nat) ) {
    receiver.proceed(new Succ(n));
}

// advice 2: norm change
Nat around(Nat n, Exam receiver) : 
					call(Exam+.setGrade(Nat)) {
    receiver.proceed(n.dec());
}
\end{lstlisting}
\caption{Source code of the example FAJ program.}
\label{fig:example}
\end{figure}

An example FAJ program --- used throughout this paper --- is shown in Figure \ref{fig:example}. It defines a class {\tt Exam}, with a field {\tt Nat grade} and a method {\tt Nat setGrade(Nat)} to update the grade. The class {\tt NamedExam} represents an exam where the student has filled in his name.\\
The classes {\tt Nat}, {\tt Zero} and {\tt Succ} represent the natural numbers; every natural number can be represented as a sequence of successors of zero. {\tt Nat} defines the method {\tt Nat add(Nat)} and {\tt Nat dec()}, that return the sum of itself and the argument, and its value decreased by one, respectively. Since FAJ does not allow interfaces, abstract classes, or empty method bodies, the methods in {\tt Nat} define the correct implementation for {\tt Zero}, which is a sub-class of {\tt Nat}. Note that the decrement of {\tt Zero} is {\tt Zero}, since -1 is not a natural number. The implementation for successors is defined in the {\tt Succ} class.\\
Two main expressions are specified (one commented) that represent the different cases we demonstrate in this paper. In the first, the exam is awarded a zero; in the second, a five.\\
After the main expression, two around advices are declared. The first specifies that, when a person filled in his name on the exam, he or she is awarded one extra point. Notice that the signature of the advice method contains the parameters of the intercepted method \emph{plus} the type of the receiver. Also, proceed is syntactically designed as a method-call on the receiver object, with the signature of the intercepted method-call.\\
The second advice describes a situation where the average score is too high and has caused a norm change; every exam is awarded one point less. When {\tt setGrade} is called on an instance of {\tt NamedExam}, both advices are triggered. This enables two interesting scenarios, caused by the initial grade (the argument of {\tt setGrade}), and the order in which the advice are executed. When a person is awarded with a grade greater then zero, the grade can be increased and decreased or decreased and increased, resulting in the same final grade. However, when a person is awarded a zero, if his grade is increased first and then decreased, the result is still zero; if the grade is decreased first and then increased, the final grade will be a one. In Section \ref{sec:simulation} we will show that we can automatically visualise such differences.

\subsection{Run-time Semantics}
\label{sec:rt}

Since in this paper we concentrate on run-time semantics, we have decided to ignore issues of static semantics, such as typing. Therefore, type casting and method overloading are not treated in our semantics.\\
The run-time semantics of this language is specified in terms of sequences of instructions. That is, every expression in the grammar can be sequentialised into a sequence of stack-based instructions of the types: {\sc call}, {\sc return}, {\sc new}, {\sc var}, {\sc get}, {\sc set}, and {\sc proceed}. In this paper, we assume that expressions are pre-evaluated into such sequences; whenever we represent an FAJ program, method-bodies consist of a sequence of instructions instead of an expression. We define the sequentialisation process as a function $mcode : Id \times T \rightarrow \overline{Instr}$ that returns a sequence of instructions given a method identifier. Given a function $mbody: Id \times T \rightarrow Expr$ that finds the body expression for a method identifier and a receiver type, this is defined as follows:

\begin{figure}[ht]
\begin{align*}
mcode(id, r)& = S(mbody(id, r));\text{\sc{return}}\\
\\
S(x)&=\text{\sc{var}}_x\\
S(e.f)&=S(e);\text{\sc{get}}_f\\
S(e_0.f=e)&=S(e);S(e_0);\text{\sc{set}}_f\\
S(\text{\sc new} \: T(e_0,\dotsc,e_n)&=S(e_0);\dotsc;S(e_n);\text{\sc{new}}_T\\
S(e.m(e_0,\dotsc,e_n)&=S(e_0);\dotsc;S(e_n);S(e);\text{\sc{call}}_m\\
S(e.\text{\sc proceed}(e_0,\dotsc,e_n)&=S(e_0);\dotsc;S(e_n);S(e);\text{\sc{proceed}}\\
\end{align*}
\caption{Sequentialisation}
\label{fig:fja_restack}
\end{figure}

Thus, the $mcode$ function will use the given identifier and type to the $mbody$ function, which looks up the method and returns the body expression. This expression is broken down into a sequence of instructions by function $S$. Finally, a {\sc return} instruction is added.\\
\\
Run-time information is stored in both a heap and a number of global stacks:
\begin{list}{$\bullet$}{}
\item A so-called \emph{continuation stack} contains the currently scheduled instructions, the top instruction being the first to be executed. Execution terminates when the continuation stack is empty.
\item The results of evaluating an expression are placed on a so-called \emph{value stack}.
\end{list}
For executing around advice, the following concepts are required:
\begin{list}{$\bullet$}{}
\item a \emph{proceed stack} is used for postponing an action that triggers an advice; {\sc proceed} instructions pop the top of the proceed stack onto the continuation stack;
\end{list}
Furthermore, a number of auxiliary instructions will be used: 
\begin{list}{$\bullet$}{}
\item a virtual {\sc pushobj} instruction: any object on the continuation stack will be popped and pushed on the value stack; 
\item a \doI{} instruction is used for invoking advices;
\item a {\sc pushp} instruction pushes the top of the continuation stack on top of the proceed stack;
\item a {\sc popp} instruction pops the top of the proceed stack;
\end{list}

When a {\sc call} instruction is matched by any aspects, these aspects are first scheduled (in a certain order) by placing a {\sc do} instruction on either the continuation stack (for the first advice), or the proceed stack (for any other advices). 
The {\sc pushp} and {\sc popp} instructions are added to achieve a uniform handling of multiple around advice, all of which may contain a {\sc proceed} instruction.
