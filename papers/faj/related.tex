\section{Related Work}\label{sec:relatedwork}

The idea of the work reported here arose from \cite{eemcs6140}, where a full graph transformation-based semantics is given for a custom defined object-oriented language. Also based on that work is the graph transformation-based semantics of a the Composition Filters language mentioned in \cite{StaijenRen2006}, that however, does not include a base language semantics and can therefore merely execute subsequent advices at a single join point. Both of these models use a different run-time state representation that is more suitable for object-oriented systems.\\
There are quite a few works describing a specification of an aspect-oriented operational semantics. Most of these approaches focus on --- like this work --- a simplified base language and aspect extension. In general, they focus on a certain feature of aspect-oriented language.\\
As mentioned before as our correctness criterion, Douence et al. \cite{DDFL-NoE06} give an operational semantics of two base languages --- a simple functional language and AFJ --- and a large number of features of aspect-oriented language. The notation used is semi-formal yet mathematical and it does not provide means for execution.
Bruns et al. \cite{Bruns04muabc:a} present a formal model for aspects in a functional language.
Clifton et al \cite{Clifton-Leavens-Wand03} give a formal definition of the parameterised aspect calculus. This is a purely mathematical specification of a base language and a variety of point-cut description languages. The specification does not provide a direct means for execution.\\
Walker et al. \cite{Walker03atheory} present a core aspect-oriented calculus based on the simple-types lambda calculus.\\
Jagadeesan et al. \cite{Jagadeesan03acalculus} give a calculus of untyped aspect-oriented programs. Their specification is class-based, and models multi-threaded programs.\\
Wand et al. \cite{Kiczales02asemantics} give a denotational semantics for a first-order procedural language with join-points for procedure-call and procedure and advice execution.\\
L\"ammel \cite{508392} presents an operational semantics for an imperative object-oriented language with join-points for method calls.
Clifton et al. \cite{Clifton-Leavens05,Clifton-Leavens05a} provides a calculus for an imperative object-oriented language with advice bindings and proceed.\\
The works mentioned all use a mathematical notation, whereas our notation is of a more intuitive visual kind. The works mentioned also do not provide a means for execution, whereas our work can be directly be used to visually represent the execution of a specific FAJ program.
