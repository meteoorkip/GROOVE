% -----------------------------------------------------------------------------
% solution.tex
% -----------------------------------------------------------------------------

\section{Solution}
\stlabel{solution}

In this section we present our \GROOVE solution for the $N$-queens puzzle, and
the results obtained. The rationale as to why the solution was modelled in this
way gives rise to a set of design guidelines, presented in \stref{discussion}.

An important feature of \GROOVE is its ability for isomorphism detection,
potentially enabling large state space reductions. For this to be applicable to
the problem at hand, the graph representation used should be modelled so as to
be isomorphic whenever possible. This means that (in terms of
\tabref{sol-count}) we aim to find \emph{unique} and not \emph{distinct}
solutions.

\subsection{Initial considerations}
\stlabel{grammar}

A \GROOVE grammar has at least two main components: a \emph{start graph},
describing an initial configuration; and a \emph{rule set}, describing the
actions to be performed. Typically, one starts by designing the start graph,
followed by the rules. However, in many cases there is an iterative cycle,
where some insights gained during rule creation lead to changes in the start
graph.

The design of a grammar is a creative process akin to programming, and as
such, some familiarity with the tools employed (programming language,
compiler, etc) is expected in order for ``effective'' solutions to be
obtained.  Analysing our experiences with novice (student) \GROOVE users, it
is clear that an important skill that needs to be acquired is the ability to
think declaratively and in terms of graph structure. Unfortunately, such
ability is hard to teach and also to condense as guidelines; it can usually
only be acquired by practice. Nevertheless, as with many intellectual
endeavours, once the proper mindset is achieved it becomes a second nature.

Continuing with the programming analogy, the definition of what an
``effective'' solution means is up to debate. In problems of the kind
considered in this paper, effectiveness certainly requires computational
efficiency. State space exploration is inherently a complex combinatorial
problem, and as such, we consider a grammar ``effective'' if it produces the
desired answer within a reasonable amount of time, and without exhausting the
available resources (\eg, memory). Once more, a ``reasonable amount of time''
is still a subjective metric, dependent on the user view of the problem
complexity. We return to this discussion in \stref{results}.

Finally, we would like to point out the interplay between certain modelling
choices and the associated difficulty in rule creation. In some cases,
resorting to a simpler start graph representation can make the rules more
complex, and therefore, harder to write. Additionally, the way a grammar is
modelled may have a significant impact on tool performance. When attacking a
new problem, we follow the motto by Knuth that ``premature optimisation is the
root of all evil''~\cite{Knu74}, and thus we initially strive for ease in
grammar design. Only after an initial grammar is crafted, if performance
happens to be problematic then some tweaking is done. Further discussion about
this point is interspersed throughout the rest of this paper.

\subsubsection{Start graph --- representing the board}

Representing a chessboard as a graph can be done in several ways. In the course
of this section we present the options that were considered until the final
representation was found.

We begin by modelling each board square as a graph node. The immediate question
that follows is which characteristics of a square should be transferred to its
associated node. We recall that a key aspect in abstracting a real-world
artefact (the chessboard) into a graph model is preventing unnecessary details
from creeping into the model. For instance, while in the real board a square
can either be ``light'' or ``dark'', this characteristic is irrelevant for
solving the puzzle, and therefore square colour is not represented in the graph
node.

Each square of the real-world $8 \times 8$ chessboard is identified by its
column (denoted with letters \emph{a} to \emph{h}) and its row (denoted with
numbers \emph{1} to \emph{8}). Such naming convention could in principle be
used to distinguish each of the 64 nodes in the graph, but we discard this
idea for two reasons:
%
\vspace{-3pt}
\begin{enumerate}\itemsep0pt
\item The valid placement of a queen in a node becomes complex to represent
in the rules, since the conditions for attacks (no other queen in the same row,
column or diagonal) have to be formulated in terms of square attributes. Note
that while such conditions can be easily expressed and tested for in a
conventional imperative programming language, when working with attributes in a
purely graph-based setting this is not so straightforward.
%
\item Making each node totally distinct from the others completely eliminates
graph symmetry under rotations and reflections. This effectively
renders the isomorphism checking of \GROOVE moot.
\end{enumerate}

\putcompfig{n-queens-grammar}{Start and final graphs for the $4$-queens
problem.}

In the end, we represent an empty square simply as an unlabelled node,
\begin{tikzpicture}\node[basic_node] {}; \end{tikzpicture} ; and a square
occupied by a queen as a \glabel{Q}-labelled node,
\begin{tikzpicture}\node[basic_node] {Q}; \end{tikzpicture} . This simplistic
node model implies that node distinction has to be based on incident edges.
\fref{n-queens-grammar}(a) shows the start graph representation used to model a
$4 \times 4$ board. Nodes are distinguished by their neighbours, identified by
the connecting edges. Edges labelled \glabel{h} and \glabel{v} indicate
horizontal and vertical neighbourhood relations, respectively. Diagonals are
distinguished by their orientation: NW-SE diagonals are called \emph{left
diagonals} and are labelled \glabel{ld}; NE-SW diagonals are called \emph{right
diagonals} and are labelled \glabel{rd}. Note that all edges are
bidirectional\footnote{\GROOVE works only with directed edges, so to represent a
symmetric relation between two nodes we have to use two opposite directed edges.
These edges are rendered in the GUI as a single bidirectional (double-arrowed)
edge to avoid visual clutter.} (\ie, undirected) since all relations are
symmetric.

\subsubsection{Rules --- constructing a solution}

It can be immediately seen that the start graph given in
\fref{n-queens-grammar}(a) has only one degree of symmetry, namely over a
$180^\circ$ rotation, due to the distinction between horizontal and vertical
edges and between left and right diagonals. However, this representation is
convenient as it allows us to solve the problem with a single rule for queen
placement. After a solution is found, we ``repair'' the board with another
rule that restores symmetry.

\fref{n-queens-rules} shows the rules of the grammar. The \glabel{place} rule
performs a single step towards a valid solution, by placing a queen in a
suitable square. The topmost node in the rule tries to find a square that does
not already have a queen, as indicated by the embargo\footnote{\emph{Embargo}
is the \GROOVE terminology for a \emph{negative application condition (NAC)}.}
condition \glabel{\color{embargo_c}! Q} inside the node. The candidate square
should also not be under attack by another existing queen: this is encoded by
the bottom (\emph{embargo}) node, coloured in red. It should not be possible
for an existing queen to reach the selected square in a straight line from any
direction, either horizontally, vertically, or diagonally. This restriction is
imposed by means of the regular expression placed in the edge:
\glabel{\color{embargo_c}h+$|$v+$|$ld+$|$rd+}. In this expression,
\glabel{\color{embargo_c}h+} matches a path in the host graph formed by one or
more \glabel{h}-edges (and similarly for the other labels), and
\glabel{\color{embargo_c}$|$} represents a path choice. If indeed a proper
square can be found, a new queen should be placed there, as indicated by the
\emph{creator} label~\glabel{\color{creator_c}+ Q} inside the reader node.

\putcompfig{n-queens-rules}{Rules of the $N$-queens solution.}
%\putfig[1.25]{rename}{Rule \glabel{rename} modifies all board labels at once
%using quantification.}

Rule \glabel{rename} (\fref{n-queens-rules}(b)) renames all edges of the board
in order to restore the other symmetries. In this way, \GROOVE can use
isomorphism checking to collapse similar final configurations, thus obtaining
only the unique solutions for the puzzle. Symmetry is achieved by renaming left
and right diagonals to \glabel{d}-edges, and by transforming horizontal and
vertical edges into \glabel{p}-edges (perpendicular).\footnote{Edges have their
label fixed upon creation so label renaming requires deleting the edge with
the old label and creating another edge with the new label. In \GROOVE,
deletions are represented by the so-called \emph{eraser} elements, drawn in
dashed blue.} The rule uses \emph{wildcard labels}
\glabel{\color{eraser_c}?[ld,rd]} and \glabel{\color{eraser_c}?[h,v]}, each of
which matches either of the labels between square brackets. Additionally,
\emph{universal quantification} modifies all edges in a single application,
thus avoiding interleaving due to independent rule applications and therefore
simplifying the state space (see \stref{discussion} for further discussion).

% \putfig[1.25]{sol-4}{Final state representing the single unique solution for the
% four queens puzzle.}

At this point one may wonder why the renamed board with only \glabel{d}-
and \glabel{p}-edges was not already used as a start graph. The reason  for
avoiding this simpler representation at the beginning is that it would make
queen placement much harder to express. For instance, the regular expression in
\fref{n-queens-rules}(a) cannot simply be replaced  by
\glabel{\color{embargo_c}p+$|$d+}, as this new condition allows paths to
``bend'' over board corners. To illustrate this problem, see
\fref{n-queens-grammar}(b), which shows the single unique solution for the
4-queens puzzle. For example, the queens at the first column and at the last
row can reach one another via a \glabel{p+} path that goes over the lower left
corner, but these queens are not attacking each other. This is a case of the
point discussed at the last paragraph of \stref{grammar}, where a compromise
between rule and start graph complexity has to be achieved.

Finally, we do not only want to \emph{find} a solution but also \emph{report}
it; in particular, we want to count the number of queens that have been
successfully placed at the end. This is what rule \glabel{count} in
\fref{n-queens-rules}(c) achieves: it quantifies over all nodes with a
\glabel{Q}-label, and lifts the count to a \emph{rule parameter} (indicated by
the black adornment on the top left corner of the \glabel{\bfseries int}-node):
for instance, if there are 4 \glabel{Q}-labelled nodes as in
\fref{n-queens-grammar}(b), applying this rule will result in a transition
bearing the label \glabel{count(4)}.

\subsubsection{Typing --- improving the solution}

The start graph and rules we have discussed above are \emph{untyped}: we have
used particular labels with a certain intuition, but there was nothing to
prevent us from choosing other labels, and nothing to warn us of a typo. This is
excellent for rapid prototyping, but at a certain stage it becomes useful to
enforce one's own representation choices by introducing a \emph{type graph},
fixing the allowed labels and assigning \emph{node types} to every node. Our
sample case is simple enough to remain understandable and maintainable in the
absence of typing: for instance, there is only a single node type (representing
a square of the board). The actual rule system made available at
\url{groove.cs.utwente.nl} does use typing.

\subsection{Control of rule application}

Rule \glabel{rename} should only be applied after all queens are placed because
it modifies the board representation expected by rule \glabel{place}. Rule
\glabel{count}, furthermore, should come after \glabel{rename} because we want
to count unique solutions modulo all possible degrees of symmetry. To ensure
such order of rule applications, we use a \emph{control program}, which
instructs \GROOVE on which rules to try, and in which order.

\lstref{control} shows the control program used in our solution. Line 1 in the
program tries to place queens in the board as long as possible, as indicated
by the keyword \texttt{\textbf{alap}}. When rule \glabel{place} can no longer
be applied we have found a valid solution for the $k$ queens coverage problem.
Among these solutions we also have the answer for the original problem when $k
= N$. Note that, by construction, the inapplicability of rule \glabel{place}
is a sufficient condition for obtaining a $k$ coverage solution; when \GROOVE
cannot find a node to apply the rule to, we can conclude that every square of
the board is either occupied or under attack.

\begin{wrapfigure}[5]{l}{0.5\linewidth}\vspace{-5mm}
\lstinputlisting[style=control,
caption=Control program for rule application.,
label=\lstlabel{control}]{n-queens-count.gps/control.gcp}
\end{wrapfigure}

After all queens are placed, control moves to line 2 of \lstref{control}, where
rule \glabel{rename} is applied. Since this rule operates over the entire board
due to quantification, only a single invocation is necessary. Following this
renaming, all distinct solutions are collapsed under isomorphism (done
automatically by the tool during exploration) and the remaining final states
correspond only to unique solutions.

The last step of the control program invokes \glabel{count} and thus marks the
final states with the corresponding number of queens. As explained above, the
rule does not actually modify the graph, but will result in a transition
labelled by the (parameterised) rule.

\subsection{Extracting information from the state space}

After the state space is fully explored and stored as a labelled transition
system (LTS), we can analyse it to obtain the desired information. For our
running example, we are interested in the number of final states marked by the
\glabel{count} rule. These states also enumerate all unique solutions of a
problem instance.

For $N$ up to five, the state space is quite small and can be directly inspected
using the LTS view of the Simulator. This approach is quite useful during
the grammar design, as it allows the user to interactively experiment with the
rules, and to have an immediate feedback after an exploration. However, for
$N > 5$ the state space grows to more than a thousand states, which renders
visual inspection unfeasible. For these cases, we use the Prolog extension of
\GROOVE~\cite{GZR+11}, which lets us query the state space programmatically.

\lstinputlisting[style=prolog,
caption=Prolog program for querying the transition system.,
label=\lstlabel{prolog}]{n-queens-count.gps/prolog.pro}

\lstref{prolog} shows the Prolog program used for state space analysis. Lines
1--7 show the definition of a predicate for finding a state in the LTS that is
the application target of the given rule. Note that the body of
\glabel{rule\_application\_target} is composed entirely of predicates created
for the Prolog extension of \GROOVE. These provide the user with the power to
access the internal \GROOVE data structures without having to delve into the
tool code.

\begin{wrapfigure}[7]{r}{0.25\linewidth}
\vspace{-10pt}
\begin{lstlisting}[style=prolog, numbers=none]
?- report(6)
  count(1): 0 states.
  count(2): 0 states.
  count(3): 0 states.
  count(4): 17 states.
  count(5): 28 states.
  count(6): 1 states.
\end{lstlisting}
\end{wrapfigure}

After exploring the state space, we use the predicate in lines 9--17 to report
the result counts. Predicate \glabel{report} selects the $N$ first elements
from the rule name list in line 12, and proceeds to collect all states marked
with each rule on the list (lines 13--14). For each collected set, its size is
printed (line 15). The results of a query for the 6-queens puzzle is shown on
the right. For a much more detailed description about the Prolog extension and
its usage, see~\cite{GZR+11}.

\subsection{Results}
\stlabel{results}

After the grammar was finished, we performed tests (state space explorations)
with $N$ ranging from 2 up to 10 \footnote{Picking a value for $N$ amounts to
selecting a properly sized start graph from the grammar.}. When analysing the
test results we are interested in two main points:
%
\vspace{-3pt}
\begin{itemize}\itemsep-3pt
\item {\bf Grammar testing}: the solution counts found for each value of $N$
should match the numbers given in \tabref{sol-count}.
\item {\bf Grammar (tool) performance}: the time required for a full space
state exploration should be ``reasonable'', when considering the state space
size of each instance.
\vspace{-3pt}
\end{itemize}

\begin{table}[t]
\centering
\small
\input{results/iso-results}
\caption{Results obtained by varying $N$ with isomorphism checking enabled.}
\tablabel{results}
\vspace{-.5cm}
\end{table}

\tabref{results} summarises the results obtained. For each value of $N$ the
corresponding line shows: the state space size in terms of state and transition
counts; the time needed to perform a full state space exploration; the number
of unique solutions with $N$ queens found; and the solution count for the $k$
queens coverage problem. We discuss each of these numbers in turn.

State space sizes show the usual explosion, \ie, an exponential growth on the
number of states w.r.t. $N$. This kind of explosion is commonplace within the
setting of combinatorial problems. The 3.8 million states computed for $N =
10$ lie around the usual limit the tool can handle. At the time of this
writing, the maximum number of states standard \GROOVE has ever reached in a
published experiment was around 7 million~\cite{GMRZ10}, for a grammar
modelling a network protocol for car platoon construction in highways. Using
an experimental version of the tool with distributed exploration, this limit
was raised to 35 million states~\cite{BKR10} but this required the use of
extra tools for parallel execution.

The fourth column of \tabref{results} lists the running times for state space
exploration using a DFS traversal\footnote{Querying times for the Prolog
program are not shown since they are negligible when compared to exploration
time.}. DFS was preferred over BFS as it usually requires less
memory~\cite{GMRZ10}. All tests were run on a 64-bit laptop with 6GB of RAM. The
running time for the 8-queens problem was slightly over 1 minute. While this
might seem high when compared to a dedicated solution written in a common
programming language, we consider this time reasonable for a solution obtained
by a general purpose tool, \ie, that has no particular heuristics for the
problem. When $N$ increases to 9 and 10, the respective running times of 12
minutes and two and half hours can no longer be considered reasonable.

Moving to the columns presenting the solution counts, we see that the unique
solutions column of \tabref{results} matches the second line in
\tabref{sol-count}. The same can be said about the results for the $k$ queens
coverage problem, where the first non-zero column in \tabref{results} shows the
minimal $k$ for solving the problem and the number of unique solutions for such
$k$. It is interesting to point out that our grammar not only finds all
solutions for the minimal $k$ and $k = N$ cases, but also all other solutions
for $k$ lying in between these extremes.
